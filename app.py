# Full updated file with fixes:
import streamlit as st
import streamlit.components.v1 as components
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import json
import base64
import os
import numpy as np
import re
from datetime import datetime
from fpdf import FPDF
import tempfile
import time
from dateutil.relativedelta import relativedelta

# --- AI LIBRARIES ---
from langchain_experimental.agents import create_pandas_dataframe_agent
from langchain_openai import ChatOpenAI

# Additional ML/NLP imports for advanced analyzer mode
from sklearn.linear_model import LinearRegression
from sklearn.feature_extraction.text import CountVectorizer

# --- CONFIGURATION ---
OPENAI_API_KEY = "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"

# Decode Item DB
try:
    encoded_data = "eyJUTC1MVEwiOiAiTEFOS0FUSUxFUyIsICJUTC1MVEwtQURNIjogIkFETUlOSVNUUkFUSU9OIiwgIlRMLUxUTC1BRE0tQURGQSI6ICJGQUNUT1JZIEFETUlOSVNUUkFUSU9OIiwgIjIwMDAzOCI6ICJGYWN0b3J5IG9mZmljZSBBQyAwMSIsICIyMDAwMzkiOiAiRmFjdG9yeSBvZmZpY2UgQUMgMDIiLCAiMjAwMDQwIjogIkZhY3Rvcnkgb2ZmaWNlIEFDIDAzIiwgIjIwMDA0MyI6ICJUUE0gc2VjcmV0YXJpYWwiLCAiMjAwMDQ3IjogIkRhaWx5IG1hbmFnZW1lbnQgcmV2aWV3IG1lZXRpbmcgcm9vbSIsICIyMDAwNTUiOiAiUHJvY3Rpb24gTWFuYWdlcnMgcm9vbSBhYyAwMSIsICIyMDAwNTYiOiAiUHJvY3Rpb24gTWFuYWdlcnMgcm9vbSBhYyAwMiIsICIyMDAwNjUiOiAiQVFNIG9mZmljZSByb29tIiwgIlRMLUxUTC1BRE0tQURITyI6ICJIRUFEIE9GRklDRSBBRE1JTklTVFJBVElPTiIsICJUTC1MVEwtRU5HIjogIkVOR0lORUVSSU5HIiwgIlRMLUxUTC1FTkctQ09NUCI6ICJDT01QUkVTUyBBSVIiLCAiVEwtTFRMLUVORy1FRU5HIjogIkVMRUNUUklDQUwgRU5HSU5FRVJJTkciLCAiMjAwMDAyIjogIkNvbXByZXNzb3IgMDEiLCAiMjAwMDAzIjogIkNvbXByZXNzb3IgMDIiLCAiMjAwMDA0IjogIkNvbXByZXNzb3IgMDMiLCAiMjAwMDA1IjogIkNvbXByZXNzb3IgMDQiLCAiMjAwMDA2IjogIkFpciBkcnllciAwMSIsICIyMDAwMDciOiAiQ29tcHJlc3NvciAwNSIsICIyMDAwMDgiOiAiQ29tcHJlc3NvciAwNiIsICIyMDAwMDkiOiAiQWlyIGRyeWVyIDAyIiwgIjIwMDAyMCI6ICJVUFMgMDEiLCAiMjAwMDIxIjogIlVQUyAwMiIsICIyMDAwMjIiOiAiVVBTIDAzIiwgIjIwMDAyMyI6ICJVUFMgMDQiLCAiMjAwMDI0IjogIlVQUyAwNSAoU3F1YXJpbmcgcGxhbnQpIiwgIjIwMDA0NCI6ICJVLlAuUyByb29tIDIiLCAiMjAwMDU5IjogIlUuUC5TIHJvb20gMyIsICIyMDAwNjMiOiAiVGVsZXBob25lIHJvb20iLCAiMjAwMDY5IjogIlUuUC5TIHJvb20gbmV3IDAxIiwgIjIwMDQ0MCI6ICJDRyIsICIyMDA0NDEiOiAiQ0ggKE5ldyBwYW5lbCkiLCAiMjAwNDQyIjogIkNJICAoTmV3IHBhbmVsKSIsICIyMDA0NDMiOiAiQ0oiLCAiMjAwNDQ0IjogIkNLIChPTEQgcGFuZWwpIiwgIjIwMDQ0NSI6ICJDQSIsICIyMDA0NDYiOiAiQ0QiLCAiMjAwNDQ3IjogIkNFMSIsICIyMDA0NDgiOiAiQ0UyIiwgIjIwMDQ0OSI6ICJDQyIsICIyMDA0NTAiOiAiQ0IxIiwgIjIwMDQ1MSI6ICJDQjIiLCAiMjAwNDUyIjogIkNTIFNvcnRpbmciLCAiMjAwNDUzIjogIkNOIiwgIjIwMDQ1NCI6ICJHbGF6ZSBNYWtpbmciLCAiMjAwNDU1IjogIk5ldyBEQi1VUFMtMUEgKE1vc2FpYyktbVdoIiwgIjIwMDQ1NiI6ICJOZXcgREItVVBTLTJBIChNb3NhaWMpLW1XaCIsICIyMDA0NTciOiAiTmV3IERCLVJBVy0xQSAoTW9zYWljKS1tV2giLCAiMjAwNDU4IjogIkNNIChVUFMgMyBSb29tKSIsICIyMDA0NTkiOiAiRGUgZHVzdCBwbGFudCAoQ0U1NDA2KSIsICIyMDA0NjAiOiAiREItTFAtMDEiLCAiMjAwNDYxIjogIkRCLUxQLTAyIiwgIjIwMDQ2MiI6ICJEQi1MUC0wMyIsICIyMDA0NjMiOiAiTmV3IFVQUyIsICIyMDA0NjQiOiAiTmV3IENoYW5nZSBPdmVyIiwgIjIwMDQ2NSI6ICJTREItVSIsICIyMDA0NjYiOiAiU0RCLTAxIiwgIjIwMDQ2NyI6ICJTREItMDIocG93ZXIgb3V0bGV0KSIsICJUTC1MVEwtRU5HLUVXUEgiOiAiRU1CVUxHQU1BIFdBVEVSIFBVTVAgSE9VU0UiLCAiVEwtTFRMLUVORy1HRU5HIjogIkdFTkVSQUwgRU5HSU5FRVJJTkciLCAiVEwtTFRMLUVORy1HRU5JIjogIkdFTkVSQVRPUlMiLCAiMjAwMDAwIjogIkdlbmVyYXRvciAgMDUiLCAiMjAwMDAxIjogIkdlbmVyYXRvciAgMDQiLCAiMzAwMDIyIjogIkdlbmVyYXRvciAgMDEiLCAiMzAwMDIzIjogIkdlbmVyYXRvciAgMDIiLCAiMzAwMDI0IjogIkdlbmVyYXRvciAgMDMiLCAiVEwtTFRMLUVORy1HU1lEIjogIkdBUyBZQVJEIiwgIlRMLUxUTC1FTkctTUVORyI6ICJNRUNIQU5JQ0FMIEVOR0lORUVSSU5HIiwgIlRMLUxUTC1FTkctTVNCUyI6ICJNQUlOIFNXSVRDSCBCT0FSRFMiLCAiVEwtTFRMLUVORy1UUkFTIjogIlRSQU5TRk9STUVSIiwgIjIwMDAxMyI6ICJUcmFuc2Zvcm1lciAwMSIsICIyMDAwMTQiOiAiVHJhbnNmb3JtZXIgMDIiLCAiMjAwMDE1IjogIlRyYW5zZm9ybWVyIDAzIiwgIjIwMDAxNiI6ICJUcmFuc2Zvcm1lciAwNCIsICIyMDAwMTciOiAiVHJhbnNmb3JtZXIgMDUiLCAiMjAwMDE4IjogIlRyYW5zZm9ybWVyIDA2IiwgIjIwMDAxOSI6ICJUcmFuc2Zvcm1lciAwNyIsICJUTC1MVEwtRU5HLVdLU1AiOiAiV09SS1NIT1AiLCAiMjAwMDc0IjogIkVuZ2luZWVyaW5nIE9mZmljZSBBQyAwMSIsICIyMDAwNzUiOiAiRW5naW5lZXJpbmcgT2ZmaWNlIEFDIDAyIiwgIjIwMDA3NiI6ICJFbmdpbmVlcmluZyBPZmZpY2UgQUMgMDMiLCAiMzAwMDI2IjogIkNlbnRyZSBMYXRoZSBNYWNoaW5lIiwgIjMwMDAyNyI6ICJVbml2ZXJzYWwgTWlsbGluZyBNYWNoaW5lIiwgIjMwMDAyOCI6ICJVbml2ZXJzYWwgRHJpbGxpbmcgTWFjaGluZS0yIiwgIjMwMDAyOSI6ICJQb3dlciBTYXciLCAiMzAwMDMwIjogIkJlbmNoIEdyaW5kZXItMSIsICIzMDAwMzEiOiAiQmVuY2ggR3JpbmRlci0yIiwgIjMwMDAzMiI6ICJXb3JrIEJlbmNoZXMiLCAiMzAwMDMzIjogIlBpcGUgVmljZSIsICIzMDAwMzQiOiAiV2VsZGluZyBUcmFuc2Zvcm1lcnMiLCAiMzAwMDM1IjogIk1hZ25ldGljIERyaWxsIiwgIjMwMDAzNiI6ICJHaWcgU2F3IiwgIjMwMDAzNyI6ICJSb2xsaW5nIE1hY2hpbmUiLCAiMzAwMDM4IjogIlN1cmZhY2UgR3JpbmRlciIsICIzMDAwMzkiOiAiVGlnICYgTWlnIFdlbGRpbmcgUGxhbnQiLCAiMzAwMDQwIjogIlBpcGUgVHJlYWQgQ3V0dGVyIiwgIjMwMDA0MSI6ICJDZW50cmUgTGF0aCBNYWNoaW5lIDIwMDBtbSIsICIzMDAwNDIiOiAiQWlyIENvbXByZXNzb3IgSEQxNUEiLCAiVEwtTFRMLUVORy1XVFBNIjogIldBVEVSIFBVTVBTIiwgIlRMLUxUTC1GSU4iOiAiRklOQU5DRSIsICJUTC1MVEwtRklOLUZJRkEiOiAiRkFDVE9SWSBGSU5BQ0UiLCAiMjAwMDMwIjogIkFjY291bnRzIHJvb20iLCAiMjAwMDMxIjogIkFjY291bnRzIElUIHJvb20iLCAiMjAwMDMyIjogIk0uIEFjY291bnRzIHJvb20iLCAiVEwtTFRMLUhPRiI6ICJIRUFEIE9GRklDRSIsICJUTC1MVEwtSFJEIjogIkhVTUFOIFJFU09VUkNFUyIsICJUTC1MVEwtSFJELUhSRkEiOiAiSFVNQU4gUkVTT1VSQ0VTIC1GQUNUT1JZIiwgIlRMLUxUTC1IUkQtSFJITyI6ICJIVU1BTiBSRVNPVVJDRVMgLUgvTyIsICIyMDAwMzMiOiAiVmlzaXRvcnMgYXJlYSIsICIyMDAwMzQiOiAiSFIgb2ZmaWNlIiwgIjIwMDAzNSI6ICJIUiBtYW5hZ2VyIHJvb20iLCAiMjAwMDM2IjogIkJvYXJkIHJvb20iLCAiMjAwMDM3IjogIk1lZGljYWwgcm9vbSIsICJUTC1MVEwtSFJELVdFTEYiOiAiV0VMRkFSRSIsICIyMDAwMjUiOiAiR3Vlc3QgaG91c2UgQUMgMDEiLCAiMjAwMDI2IjogIkd1ZXN0IGhvdXNlIEFDIDAyIiwgIjIwMDAyNyI6ICJHdWVzdCBob3VzZSBBQyAwMyIsICIyMDAwMjgiOiAiQmFjaGVsb3IncyBxdWFydGVycyBBQyAwMSIsICIyMDAwMjkiOiAiQmFjaGVsb3IncyBxdWFydGVycyBBQyAwMiIsICIyMDA0NjkiOiAiUm9hZCBTd2VlcGVyIiwgIlRMLUxUTC1NSVMiOiAiTUlTQ0VMQU5JT1VTIiwgIlRMLUxUTC1NS1QiOiAiTUFSS0VUVElORyIsICJUTC1MVEwtTUtULU1BS1QiOiAiTUFSS0VUVElORyIsICJUTC1MVEwtTUtULVNBTEUiOiAiU0FMRVMiLCAiVEwtTFRMLU1LVC1TSFJNIjogIlNIT1dST09NIiwgIlRMLUxUTC1PRkYiOiAiT0ZGSUNFIiwgIlRMLUxUTC1PRkYtTlVHRSI6ICJPRkZJQ0UtTlVHRUdPREEiLCAiVEwtTFRMLVBSRCI6ICJQUk9EVUNUSU9OIiwgIjIwMDA3NyI6ICJ3YXRlcmpldCIsICIyMDAwNzgiOiAiZ2FzIGxpbmUgc3lzdGVtIiwgIjIwMDA3OSI6ICJWYXBvcml6ZXIgMDEiLCAiMjAwMDgwIjogIlZhcG9yaXplciAwMiIsICIyMDAwODEiOiAiVmFwb3JpemVyIDAzIiwgIlRMLUxUTC1QUkQtR0xaTSI6ICJHTEFaRSBNQUtJTkcgUExBTlQiLCAiMTAwMDk1IjogIkdsYXplIEJhbGwgTWlsbCAxIiwgIjEwMDA5NiI6ICJHbGF6ZSBCYWxsIE1pbGwgMiIsICIxMDAwOTciOiAiR2xhemUgQmFsbCBNaWxsIDMiLCAiMTAwMDk4IjogIkdsYXplIEJhbGwgTWlsbCA0IiwgIjEwMDA5OSI6ICJHbGF6ZSBCYWxsIE1pbGwgNSIsICIxMDAxMDAiOiAiR2xhemUgQmFsbCBNaWxsIDYiLCAiMTAwMTAxIjogIkdsYXplIEJhbGwgTWlsbCA3IiwgIjEwMDEwMiI6ICJHbGF6ZSBCYWxsIE1pbGwgOCIsICIxMDAxMDMiOiAiR2xhemUgQmFsbCBNaWxsIDkiLCAiMTAwMTA0IjogIkdsYXplIEJhbGwgTWlsbCAxMCIsICIxMDAxMDUiOiAiR2xhemUgQmFsbCBNaWxsIDExIiwgIjEwMDEwNiI6ICJHbGF6ZSBCYWxsIE1pbGwgMTMiLCAiMTAwMTA3IjogIkV1cm8gTWlsbCAxIiwgIjEwMDEwOCI6ICJFdXJvIE1pbGwgMiIsICIxMDAxMDkiOiAiSG9pc3QgMSIsICIxMDAxMTAiOiAiSG9pc3QgMiIsICIxMDAxMTEiOiAiSG9pc3QgMyIsICIxMDAxMTIiOiAiTWFpbiBTY2FsZXMgMSIsICIxMDAxMTMiOiAiTWFpbiBTY2FsZXMgMiIsICIxMDAxMTQiOiAiR2xhemUgVW5sb2FkaW5nIFNlaXZlIDEiLCAiMTAwMTE1IjogIkdsYXplIFVubG9hZGluZyBTZWl2ZSAyIiwgIjEwMDExNiI6ICIgQWdpdGF0ZXIgVGFuayAwMSIsICIxMDAxMTciOiAiIEFnaXRhdGVyIFRhbmsgMDIiLCAiMTAwMTE4IjogIiBBZ2l0YXRlciBUYW5rIDAzIiwgIjEwMDExOSI6ICIgQWdpdGF0ZXIgVGFuayAwNCIsICIxMDAxMjAiOiAiIEFnaXRhdGVyIFRhbmsgMDUiLCAiMTAwMTIxIjogIiBBZ2l0YXRlciBUYW5rIDA2IiwgIjEwMDEyMiI6ICIgQWdpdGF0ZXIgVGFuayAwNyIsICIxMDAxMjMiOiAiIEFnaXRhdGVyIFRhbmsgMDgiLCAiMTAwMTI0IjogIiBBZ2l0YXRlciBUYW5rIDA5IiwgIjEwMDEyNSI6ICIgQWdpdGF0ZXIgVGFuayAxMCIsICIxMDAxMjYiOiAiIEFnaXRhdGVyIFRhbmsgMTEiLCAiMTAwMTI3IjogIiBBZ2l0YXRlciBUYW5rIDEyIiwgIjEwMDEyOCI6ICIgQWdpdGF0ZXIgVGFuayAxMyIsICIxMDAxMjkiOiAiIEFnaXRhdGVyIFRhbmsgMTQiLCAiMTAwMTMwIjogIiBBZ2l0YXRlciBUYW5rIDE1IiwgIjEwMDEzMSI6ICIgQWdpdGF0ZXIgVGFuayAxNiIsICIxMDAxMzIiOiAiIEFnaXRhdGVyIFRhbmsgMTciLCAiMTAwMTMzIjogIiBBZ2l0YXRlciBUYW5rIDE4IiwgIjEwMDEzNCI6ICIgQWdpdGF0ZXIgVGFuayAxOSIsICIxMDAxMzUiOiAiMSBBZ2l0YXRlciB0dWJzIiwgIjEwMDEzNiI6ICIyIEFnaXRhdGVyIHR1YnMiLCAiMTAwMTM3IjogIjMgQWdpdGF0ZXIgdHVicyIsICIxMDAxMzgiOiAiNCBBZ2l0YXRlciB0dWJzIiwgIjEwMDEzOSI6ICI1IEFnaXRhdGVyIHR1YnMiLCAiMTAwMTQwIjogIjYgQWdpdGF0ZXIgdHVicyIsICJUTC1MVEwtUFJELU1PU1EiOiAiTU9TQUlDIFBMQU5UIiwgIlRMLUxUTC1QUkQtTU9TUS1HTFozIjogIlVua25vd24gQXNzZXQiLCAiMTAwMzUyIjogIkZsYXQgQmVsdCBjb252ZXlvciBMMyIsICIxMDAzNTQiOiAiTW92aW5nIEJydXNoIEwzIiwgIjEwMDM1NiI6ICJSb2xsZXIgQnJ1c2ggTDMiLCAiMTAwMzU4IjogIlBuZXVtYXRpYyBkdXN0IHJlbW92ZXIgTDMiLCAiMTAwMzYwIjogIlRyYW5zZmVyIEFybSBCZWZvcmUgZ2xhemluZyBMMyIsICIxMDAzNjIiOiAiRW5nb2JlIENhYmluIEwzIiwgIjEwMDM2NCI6ICJCYXNlIENhYmluIEwzIiwgIjEwMDM2NiI6ICJUcmFuc2ZlciBBcm0gQWZ0ZXIgZ2xhemluZyBMMyIsICIxMDAzNjgiOiAiU3VjdGlvbiBVbml0IEwzIiwgIjEwMDM3MCI6ICJ2aWJyYXRpbmcgc2lldmUgTDMiLCAiMTAwMzcyIjogIkFpciBMZXNzIE1hY2hpbmUgTDMiLCAiMTAwMzc0IjogIlJvbGxlciBiZWQgY29udmV5b3IgbGluZS0wMSIsICIxMDAzNzUiOiAiUm9sbGVyIGJlZCBjb252ZXlvciBsaW5lLTAyIiwgIjEwMDM3OCI6ICJEaWdpdGFsIFByaW50aW5nIG1hY2hpbmUiLCAiMTAwMzc5IjogIlJvbGxlciBiZWQgY29udmV5b3IgYnkgcGFzcyBsaW5lIiwgIjEwMDM4MCI6ICJUcmFuc2ZlciBBcm0tRGlnaXRhbCBwcmludGluZyIsICJUTC1MVEwtUFJELU1PU1EtR0xaNCI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDM1MyI6ICJGbGF0IEJlbHQgY29udmV5b3IgTDQiLCAiMTAwMzU1IjogIk1vdmluZyBCcnVzaCBMNCIsICIxMDAzNTciOiAiUm9sbGVyIEJydXNoIEw0IiwgIjEwMDM1OSI6ICJQbmV1bWF0aWMgZHVzdCByZW1vdmVyIEw0IiwgIjEwMDM2MSI6ICJUcmFuc2ZlciBBcm0gQmVmb3JlIGdsYXppbmcgTDQiLCAiMTAwMzYzIjogIkVuZ29iZSBDYWJpbiBMNCIsICIxMDAzNjUiOiAiQmFzZSBDYWJpbiBMNCIsICIxMDAzNjciOiAiVHJhbnNmZXIgQXJtIEFmdGVyIGdsYXppbmcgTDQiLCAiMTAwMzY5IjogIlN1Y3Rpb24gVW5pdCBMNCIsICIxMDAzNzEiOiAidmlicmF0aW5nIHNpZXZlIEw0IiwgIjEwMDM3MyI6ICJBaXIgTGVzcyBNYWNoaW5lIEw0IiwgIjEwMDM3NiI6ICJSb2xsZXIgYmVkIGNvbnZleW9yIGxpbmUtMDMiLCAiMTAwMzc3IjogIlJvbGxlciBiZWQgY29udmV5b3IgbGluZS0wNCIsICJUTC1MVEwtUFJELU1PU1EtS0lMTiI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDM4MSI6ICJDb21wZW5zYXRvci0wMShraWxuIGluKSIsICIxMDAzODIiOiAiS2lsbiBpbiBSb2xsZXIgYmVkIGNvbnZleW9yIiwgIjEwMDM4MyI6ICJLaWxuIDIiLCAiMTAwMzg0IjogIktpbG4gMiBTdGFuZGJ5IGdlbmF0YXRvciIsICIxMDAzODUiOiAiS2lsbiBvdXQgUm9sbGVyIGJlZCBjb252ZXlvciIsICIxMDAzODYiOiAiQ2hhaW4gQ29udmV5b3IiLCAiMTAwMzg3IjogIlVuZGVyIEVuZ29iZSBjYWJpbiIsICIxMDAzODgiOiAidmlicmF0aW5nIHNpZXZlIiwgIjEwMDM4OSI6ICJDb21wZW5zYXRvci0wMiIsICIyMDAwNTEiOiAia2lsbiByb29tIDIiLCAiVEwtTFRMLVBSRC1NT1NRLU1UTDEiOiAiVW5rbm93biBBc3NldCIsICIxMDAzOTAiOiAiTW91bnRpbmcgbGluZSAwMSIsICI1MDAwMTIiOiAiTU9TQUlDIEFVVE8gU1RSQVBQSU5HIFRPT0wgMDEiLCAiVEwtTFRMLVBSRC1NT1NRLU1UTDIiOiAiVW5rbm93biBBc3NldCIsICIxMDAzOTEiOiAiTW91bnRpbmcgbGluZSAwMiIsICI1MDAwMTMiOiAiTU9TQUlDIEFVVE8gU1RSQVBQSU5HIFRPT0wgMDIiLCAiVEwtTFRMLVBSRC1NT1NRLU1UTDMiOiAiVW5rbm93biBBc3NldCIsICIxMDAzOTIiOiAiTW91bnRpbmcgbGluZSAwMyIsICI1MDAwMTQiOiAiTU9TQUlDIEFVVE8gU1RSQVBQSU5HIFRPT0wgMDMiLCAiVEwtTFRMLVBSRC1NT1NRLU1UTDQiOiAiVW5rbm93biBBc3NldCIsICIxMDAzOTMiOiAiTW91bnRpbmcgbGluZSAwNCIsICIxMDAzOTQiOiAiSW5kaXZpZHVhbCBQYWNraW5nIE1hY2hpbmUiLCAiMTAwMzk1IjogIlUyIG1vYmlsZSBwcmludGVyIiwgIjUwMDAxNSI6ICJNT1NBSUMgQVVUTyBTVFJBUFBJTkcgVE9PTCAwNCIsICJUTC1MVEwtUFJELU1PU1EtUFJFMyI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDM0MiI6ICJQcmVzcygxNDAwKSIsICIxMDAzNDQiOiAiQUNQIiwgIjEwMDM0NSI6ICJBTE0iLCAiMTAwMzQ2IjogIlByZXNzIGNvb2xpbmcgbWFjaGluZSAgTDMiLCAiVEwtTFRMLVBSRC1NT1NRLVBSRTQiOiAiVW5rbm93biBBc3NldCIsICIxMDAzNDMiOiAicHJlc3MgZmVlZGVyIChEQ1ApIEwzIiwgIjEwMDM0NyI6ICJQcmVzcyg5ODApIiwgIjEwMDM0OCI6ICJwcmVzcyBmZWVkZXIgKERDUCkgTDQiLCAiMTAwMzQ5IjogIkFDUCIsICIxMDAzNTAiOiAiQUxNIiwgIjEwMDM1MSI6ICJQcmVzcyBjb29saW5nIG1hY2hpbmUgIEw0IiwgIlRMLUxUTC1QUkQtUEZQTCI6ICJQUkVTUyBGRUVESU5HIFBPV0RFUiBMSU5FUyIsICIxMDAwNzQiOiAiU2lsbyBkaXNjaGFyZ2VyIDEiLCAiMTAwMDc1IjogIlNpbG8gZGlzY2hhcmdlciAyIiwgIjEwMDA3NiI6ICJTaWxvIGRpc2NoYXJnZXIgMyIsICIxMDAwNzciOiAiU2lsbyBkaXNjaGFyZ2VyIDQiLCAiMTAwMDc4IjogIlNpbG8gZGlzY2hhcmdlciA1IiwgIjEwMDA3OSI6ICJTaWxvIGRpc2NoYXJnZXIgNiIsICIxMDAwODAiOiAiU2lsbyBkaXNjaGFyZ2VyIDciLCAiMTAwMDgxIjogIlNpbG8gZGlzY2hhcmdlciA4IiwgIjEwMDA4MiI6ICJTaWxvIGRpc2NoYXJnZXIgOSIsICIxMDAwODMiOiAiU2lsbyBkaXNjaGFyZ2VyIDEwIiwgIjEwMDA4NCI6ICJTaWxvIGRpc2NoYXJnZXIgMTEiLCAiMTAwMDg1IjogIlNpbG8gZGlzY2hhcmdlciAxMiIsICIxMDAwODYiOiAiU2lsbyBkaXNjaGFyZ2VyIDEzIiwgIjEwMDA4NyI6ICJCdWNrZXQgZWxldmF0b3IgMSIsICIxMDAwODgiOiAiQnVja2V0IGVsZXZhdG9yIDIiLCAiMTAwMDg5IjogIkJ1Y2tldCBlbGV2YXRvciAzIiwgIjEwMDA5MCI6ICJDb252ZXlvcnMiLCAiMTAwMDkxIjogIlZpYnJhdGluZyBzY3JlZW4gMTEiLCAiMTAwMDkyIjogIlZpYnJhdGluZyBzY3JlZW4gMTIiLCAiMTAwMDkzIjogIlZpYnJhdGluZyBzY3JlZW4gMTMiLCAiMTAwMDk0IjogIlZpYnJhdGluZyBzY3JlZW4gMTQiLCAiMTAwNDYxIjogIkR1c3Qgc3VjdGlvbnMgZHJ5IHR5cGUgNyIsICIzMDAwMjUiOiAiUG93ZGVyIGxpbmUgcGFuZWwiLCAiVEwtTFRMLVBSRC1QTFQxIjogIlBMQU5UIDEiLCAiMjAwMDEyIjogIkR1c3Qgc3VjdGlvbnMgZHJ5IHR5cGUgMyIsICJUTC1MVEwtUFJELVBMVDEtR0xaMSI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDE3NSI6ICJTcGFjZXIgTDEiLCAiMTAwMTc3IjogIkFpcmxlc3Mgd2F0ZXIgc3ByYXkgbWFjaGluZSBMMS0xIiwgIjEwMDE3OCI6ICJBaXJsZXNzIHdhdGVyIHNwcmF5IG1hY2hpbmUgIEwxLTIiLCAiMTAwMTgxIjogIlNwcmF5IGNhYmlucyBMMSIsICIxMDAxODMiOiAiQmVsbCBtYWNoaW5lIEwxIiwgIjEwMDE4NSI6ICJ2ZWxhIG1hY2hpbmUgTDEiLCAiMTAwMTg3IjogIkdsYXppbmcgdHVicyBMMS0xIiwgIjEwMDE4OCI6ICJHbGF6aW5nIHR1YnMgTDEtMiIsICIxMDAxODkiOiAiR2xhemluZyB0dWJzIEwxLTMiLCAiMTAwMTkwIjogIkdsYXppbmcgdHVicyBMMS00IiwgIjEwMDE5NSI6ICJWaWJyYXRpbmcgc2lldmUgIEwxLTEiLCAiMTAwMTk2IjogIlZpYnJhdGluZyBzaWV2ZSAgTDEtMiIsICIxMDAxOTkiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsICkgTDEtMSIsICIxMDAyMDAiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsICkgTDEtMiIsICIxMDAyMDEiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsICkgTDEtMyIsICIxMDAyMDIiOiAiVmVydGljYWwgcHVtcHMgKCBsYXJnZSkgTDEtMSIsICIxMDAyMDMiOiAiVmVydGljYWwgcHVtcHMgKCBsYXJnZSkgTDEtMiIsICIxMDAyMDUiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsICkgTDItMSIsICIxMDAyMDYiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsICkgTDItMiIsICIxMDAyMDciOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsICkgTDItMyIsICIxMDAyMDgiOiAiVmVydGljYWwgcHVtcHMgKCBsYXJnZSkgTDItMSIsICIxMDAyMDkiOiAiVmVydGljYWwgcHVtcHMgKCBsYXJnZSkgTDItMiIsICIxMDAyMTEiOiAiVGlsZSBUdXJuZXIgYmVkIEwxIiwgIjEwMDIxMyI6ICJXZXQgc2NyYXBlciBMMS0xIiwgIjEwMDIxNSI6ICJCbG93ZXJzIEwxIiwgIjEwMDIxNyI6ICJEaWdpdGFsIG1hY2hpbmUgTDEiLCAiMTAwMjE5IjogIkRyb3AgY2FiaW4gTDEiLCAiMTAwMjIxIjogIlN0ZXAgYnkgc3RlcCBiZWx0IEwxIiwgIjEwMDIyMyI6ICJSb2xsZXJtYXRpYyBMMSIsICIxMDA0NjQiOiAibGluZSBjb252ZXlvciAtIDEiLCAiMjAwMDUzIjogImxpbmUgMS1kaWdpdGFsIHJvb20gYWMgMDEiLCAiMjAwMDU0IjogImxpbmUgMS1kaWdpdGFsIHJvb20gYWMgMDIiLCAiVEwtTFRMLVBSRC1QTFQxLUdMWjIiOiAiVW5rbm93biBBc3NldCIsICIxMDAxNzYiOiAiU3BhY2VyIEwyIiwgIjEwMDE3OSI6ICJBaXJsZXNzIHdhdGVyIHNwcmF5IG1hY2hpbmUgTDItMSIsICIxMDAxODAiOiAiQWlybGVzcyB3YXRlciBzcHJheSBtYWNoaW5lICBMMi0yIiwgIjEwMDE4MiI6ICJTcHJheSBjYWJpbnMgTDIiLCAiMTAwMTg0IjogIkJlbGwgbWFjaGluZSBMMiIsICIxMDAxODYiOiAidmVsYSBtYWNoaW5lIEwyIiwgIjEwMDE5MSI6ICJHbGF6aW5nIHR1YnMgTDItMSIsICIxMDAxOTIiOiAiR2xhemluZyB0dWJzIEwyLTIiLCAiMTAwMTkzIjogIkdsYXppbmcgdHVicyBMMi0zIiwgIjEwMDE5NCI6ICJHbGF6aW5nIHR1YnMgTDItNCIsICIxMDAxOTciOiAiVmlicmF0aW5nIHNpZXZlICBMMi0xIiwgIjEwMDE5OCI6ICJWaWJyYXRpbmcgc2lldmUgIEwyLTIiLCAiMTAwMjA0IjogIlZlcnRpY2FsIHB1bXBzICggbGFyZ2UpIEwxLTMiLCAiMTAwMjEwIjogIlZlcnRpY2FsIHB1bXBzICggbGFyZ2UpIEwyLTMiLCAiMTAwMjEyIjogIlRpbGUgVHVybmVyIGJlZCBMMiIsICIxMDAyMTQiOiAiV2V0IHNjcmFwZXIgTDItMSIsICIxMDAyMTYiOiAiQmxvd2VycyBMMiIsICIxMDAyMTgiOiAiRGlnaXRhbCBtYWNoaW5lIEwyIiwgIjEwMDIyMCI6ICJEcm9wIGNhYmluIEwyIiwgIjEwMDIyMiI6ICJTdGVwIGJ5IHN0ZXAgYmVsdCBMMiIsICIxMDAyMjQiOiAiUm9sbGVybWF0aWMgTDIiLCAiMTAwNDY1IjogImxpbmUgY29udmV5b3IgLSAyIiwgIjIwMDA1MiI6ICJMaW5lIDItZGlnaXRhbCByb29tIiwgIlRMLUxUTC1QUkQtUExUMS1LSUxOIjogIlVua25vd24gQXNzZXQiLCAiMTAwMjI1IjogIktpbG4gMSBSb2xsZXJtYXRpYyBtYWNoaW5lIiwgIjEwMDIyNiI6ICJLaWxuIDAxIGZlZWRlciBwYW5lbCIsICIxMDAyMjciOiAiS2lsbiBGZWVkaW5nIFJvbGxlciBiZWRzIEsxIiwgIjEwMDIyOCI6ICJraWxuIDEiLCAiMTAwMjI5IjogIktpbG4gMSBTdGFuZGJ5IGdlbmFyYXRhdG9yIiwgIjEwMDIzMCI6ICJLaWxuIDEgZXhpdCBjb252ZXlvcnMiLCAiMTAwMjMxIjogIktpbG4gMSBDb250YWluZXIgbG9hZGluZyBNYWNoaW5lIiwgIjIwMDA1NyI6ICJraWxuIHJvb20gMSIsICJUTC1MVEwtUFJELVBMVDEtUFJFMSI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDE0MSI6ICJQcmVzcyBMMSIsICIxMDAxNDIiOiAiUHJlc3MgMDEgcGFuZWwgQUMiLCAiMTAwMTQzIjogIlByZXNzIDAxIG1hY2hpbmUgcGFuZWwgQUMiLCAiMTAwMTQ0IjogInByZXNzIGZlZWRlciAoRENQKUwxIiwgIjEwMDE0NSI6ICJBQ1AiLCAiMTAwMTQ2IjogIkFMTSIsICIxMDAxNDciOiAiUHJlc3MgY29vbGluZyBtYWNoaW5lICBMMSIsICIxMDAxNTUiOiAiUHJlc3MgZXhpdCBjb252ZXllcnMgTDEiLCAiMTAwMTU3IjogIlByZXNzIEJydXNoIE1hY2hpbmUgTDEiLCAiMTAwMTU5IjogIlRpbGUgYm90dG9tIHNpZGUgc2NyYXBlciBicnVzaCBMMSIsICIxMDAxNjEiOiAiVGlsZSBUdXJuZXIgTDEiLCAiMTAwMTYzIjogIlRpbGUgc3VyZmFjZSBzY3JhcGVyIGJydXNoIEwxIiwgIlRMLUxUTC1QUkQtUExUMS1QUkUyIjogIlVua25vd24gQXNzZXQiLCAiMTAwMTQ4IjogIlByZXNzIEwyIiwgIjEwMDE0OSI6ICJwcmVzcyAwMiBwYW5lbCBBQyIsICIxMDAxNTAiOiAiUHJlc3MgMDIgbWFjaGluZSBwYW5lbCBBQyIsICIxMDAxNTEiOiAicHJlc3MgZmVlZGVyIChEQ1ApTDIiLCAiMTAwMTUyIjogIkFDUCIsICIxMDAxNTMiOiAiQUxNIiwgIjEwMDE1NCI6ICJQcmVzcyBjb29saW5nIG1hY2hpbmUgIEwyIiwgIjEwMDE1NiI6ICJQcmVzcyBleGl0IGNvbnZleWVycyBMMiIsICIxMDAxNTgiOiAiUHJlc3MgQnJ1c2ggTWFjaGluZSBMMiIsICIxMDAxNjAiOiAiVGlsZSBib3R0b20gc2lkZSBzY3JhcGVyIGJydXNoIEwyIiwgIjEwMDE2MiI6ICJUaWxlIFR1cm5lciBMMiIsICIxMDAxNjQiOiAiVGlsZSBzdXJmYWNlIHNjcmFwZXIgYnJ1c2ggTDIiLCAiVEwtTFRMLVBSRC1QTFQxLVNRUkUiOiAiVW5rbm93biBBc3NldCIsICIxMDA0MzciOiAiY29udGFpbmVyIHVubG9hZGluZyhvbGQpIiwgIjEwMDQzOCI6ICIxU1QgUEhBU0UgU1FVQVJJTkcgTUFDSElORShvbGQgc3F1YWluZyApIiwgIjEwMDQzOSI6ICJUVVJOSU5HIERFVklDRSIsICIxMDA0NDAiOiAiMk5EIFBIQVNFIFNRVUFSSU5HIE1BQ0hJTkUob2xkIHNxdWFpbmcgKSIsICIxMDA0NDEiOiAiY29udGFpbmVyIGxvYWRpbmcgKG9sZCkiLCAiMTAwNDQyIjogIkhvdCBBaXIgYmxvd2VyIHVuaXQiLCAiMTAwNDQzIjogImFwcGxlIGdhdWdlIG1hY2hpbmUiLCAiVEwtTFRMLVBSRC1QTFQxLVZEUjEiOiAiVW5rbm93biBBc3NldCIsICIxMDAxNjUiOiAiUm9sbGVyIGJlZCBMMSIsICIxMDAxNjciOiAiTXVsdGlwbGllciBjb252ZXlvciBMMSIsICIxMDAxNjkiOiAiVmVydGljYWwgZHJ5ZXIgTDEiLCAiMTAwMTcwIjogIlZlcnRpY2FsIGRyeWVyIDAxIHBhbmVsIEFDIiwgIjEwMDE3MyI6ICJCcnVzaCBhbmQgU3VjdGlvbiBMMSIsICJUTC1MVEwtUFJELVBMVDEtVkRSMiI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDE2NiI6ICJSb2xsZXIgYmVkIEwyIiwgIjEwMDE2OCI6ICJNdWx0aXBsaWVyIGNvbnZleW9yIEwyIiwgIjEwMDE3MSI6ICJWZXJ0aWNhbCBkcnllciBMMiIsICIxMDAxNzIiOiAiVmVydGljYWwgZHJ5ZXIgMDIgcGFuZWwgQUMiLCAiMTAwMTc0IjogIkJydXNoIGFuZCBTdWN0aW9uIEwyIiwgIlRMLUxUTC1QUkQtUExUMi1TUVJFIjogIlNRVUFSSU5HIiwgIjEwMDQ0OCI6ICIxU1QgUEhBU0UgU1FVQVJJTkcgTUFDSElORSIsICIxMDA0NDkiOiAiVFVSTklORyBERVZJQ0UiLCAiMTAwNDUwIjogIjJORCBQSEFTRSBTUVVBUklORyBNQUNISU5FIiwgIjEwMDQ1MSI6ICJST0JPRkxPQVIiLCAiMTAwNDUyIjogIkFJUiBCTE9XSU5HIFVOSVQiLCAiMTAwNDUzIjogImFwcGxlIGdhdWdlIG1hY2hpbmUiLCAiMTAwNDU0IjogIndheCBtYWNoaW5lIiwgIlRMLUxUTC1QUkQtUExUMyI6ICJQTEFOVCAzIiwgIjEwMDQ1OCI6ICJEdXN0IHN1Y3Rpb25zIGRyeSB0eXBlIDQiLCAiMTAwNDU5IjogIkR1c3Qgc3VjdGlvbnMgZHJ5IHR5cGUgNSIsICJUTC1MVEwtUFJELVBMVDMtR0xaNSI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDI0NyI6ICJTcGFjZXIiLCAiMTAwMjQ4IjogIkJydXNoIGFuZCBTdWN0aW9uMSIsICIxMDAyNDkiOiAiQnJ1c2ggYW5kIFN1Y3Rpb24yIiwgIjEwMDI1MCI6ICJBaXJsZXNzIHdhdGVyIHNwcmF5IG1hY2hpbmUgTDUtIDEiLCAiMTAwMjUxIjogIkFpcmxlc3Mgd2F0ZXIgc3ByYXkgbWFjaGluZSBMNS0gMiIsICIxMDAyNTIiOiAiU3ByYXkgY2FiaW5zIiwgIjEwMDI1MyI6ICJ2ZWxhIG1hY2hpbmVzIEw1LSAxIiwgIjEwMDI1NCI6ICJ2ZWxhIG1hY2hpbmVzIEw1LSAyIiwgIjEwMDI1NSI6ICJHbGF6aW5nIHR1YnMgTDUgLSAxICh0dWIgd2l0aCBhZ2l0YXRvcikiLCAiMTAwMjU2IjogIkdsYXppbmcgdHVicyBMNSAtIDIgKHR1YiB3aXRoIGFnaXRhdG9yKSIsICIxMDAyNTciOiAiR2xhemluZyB0dWJzIEw1IC0gMyAodHViIHdpdGggYWdpdGF0b3IpIiwgIjEwMDI1OCI6ICJHbGF6aW5nIHR1YnMgTDUgLSA0ICh0dWIgd2l0aCBhZ2l0YXRvcikiLCAiMTAwMjU5IjogIlZpYnJhdGluZyBzaWV2ZSIsICIxMDAyNjAiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsKSBMNS0wMSIsICIxMDAyNjEiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsKSBMNS0wMiIsICIxMDAyNjIiOiAiVmVydGljYWwgcHVtcHMgKHNtYWxsKSBMNS0wMyIsICIxMDAyNjMiOiAiVmVydGljYWwgcHVtcHMgKGxhcmdlKUw1IC0gMDEiLCAiMTAwMjY0IjogIlZlcnRpY2FsIHB1bXBzIChsYXJnZSlMNSAtIDAyIiwgIjEwMDI2NSI6ICJWZXJ0aWNhbCBwdW1wcyAobGFyZ2UpTDUgLSAwMyIsICIxMDAyNjYiOiAiVGlsZSBUdXJuZXIgQmVkIiwgIjEwMDI2NyI6ICJXZXQgc2NyYXBlciBMNS0xIiwgIjEwMDI2OCI6ICJSb3RvIGNvbG91ciIsICIxMDAyNjkiOiAiQmxvd2VycyIsICIxMDAyNzAiOiAiRGlnaXRhbCBtYWNoaW5lIiwgIjEwMDI3MSI6ICJEcm9wIGNhYmluIiwgIjEwMDI3MiI6ICJTdGVwIGJ5IHN0ZXAgYmVsdCIsICIxMDAyNzMiOiAiUm9sbGVybWF0aWMgbWFjaGluZSIsICIxMDA0NjYiOiAibGluZSBjb252ZXlvciAtIDUiLCAiMjAwMDQ1IjogIkxpbmUgNS1EaWdpdGFsIHJvb20iLCAiVEwtTFRMLVBSRC1QTFQzLUtJTE4iOiAiVW5rbm93biBBc3NldCIsICIxMDAyNzQiOiAiS2lsbiAzIFJvbGxlcm1hdGljIG1hY2hpbmUiLCAiMTAwMjc1IjogIktpbG4gMyBGZWVkaW5nIFJvbGxlciBiZWRzIiwgIjEwMDI3NiI6ICJraWxuIDMiLCAiMTAwMjc3IjogIktpbG4gMyBTdGFuZGJ5IGdlbmF0YXRvciIsICIxMDAyNzgiOiAiS2lsbiAzIGV4aXQgY29udmV5b3JzIiwgIjEwMDI3OSI6ICJLaWxuIDMgQ29udGFpbmVyIGxvYWRpbmcgTWFjaGluZSIsICIyMDAwNDkiOiAia2lsbiByb29tIDMgYWMgMDEiLCAiMjAwMDUwIjogImtpbG4gcm9vbSAzIGFjIDAyIiwgIlRMLUxUTC1QUkQtUExUMy1QUkU1IjogIlVua25vd24gQXNzZXQiLCAiMTAwMjMyIjogIlByZXNzIDUiLCAiMTAwMjMzIjogIlByZXNzIEZlZWRlcihEQ0wpIiwgIjEwMDIzNCI6ICJBQ1AiLCAiMTAwMjM1IjogIkFMTSIsICIxMDAyMzYiOiAicHJlc3MgMDUgcGFuZWwgQUMiLCAiMTAwMjM3IjogIlByZXNzIDA1IG1hY2hpbmUgcGFuZWwgQUMiLCAiMTAwMjM4IjogIlByZXNzIGNvb2xpbmcgbWFjaGluZSAgTDUiLCAiMTAwMjM5IjogIlByZXNzIGV4aXQgY29udmV5ZXJzIiwgIjEwMDI0MCI6ICJUaWxlIGJvdHRvbSBzaWRlIHNjcmFwZXIgYnJ1c2giLCAiMTAwMjQxIjogIlRpbGUgVHVybmVyIChSUFIpIiwgIjEwMDI0MiI6ICJUaWxlIHN1cmZhY2Ugc2NyYXBlciBicnVzaCIsICJUTC1MVEwtUFJELVBMVDMtU1FSRSI6ICJVbmtub3duIEFzc2V0IiwgIjEwMTQ4OSI6ICIxU1QgUEhBU0UgU1FVQVJJTkcgTUFDSElORShEcnkgU3F1YSkiLCAiMTAxNDkwIjogIlRVUk5JTkcgREVWSUNFIiwgIjEwMTQ5MSI6ICIyTkQgUEhBU0UgU1FVQVJJTkcgTUFDSElORShEcnkgU3F1YSkiLCAiMTAxNDkyIjogIkFpciBTdWN0aW9uIFVuaXQiLCAiMTAxNTAwIjogIkNvbnRhaW5lciBVbmxvYWRpbmciLCAiVEwtTFRMLVBSRC1QTFQzLVZEUlkiOiAiVW5rbm93biBBc3NldCIsICIxMDAyNDMiOiAiTXVsdGlwbGllciBjb252ZXlvciIsICIxMDAyNDQiOiAiUm9sbGVyIGJlZCIsICIxMDAyNDUiOiAiVmVydGljYWwgRHJ5ZXIiLCAiMTAwMjQ2IjogIlZlcnRpY2FsIGRyeWVyIDA1IHBhbmVsIEFDIiwgIlRMLUxUTC1QUkQtUExUNCI6ICJQTEFOVCA0IiwgIjEwMDQ2MCI6ICJEdXN0IHN1Y3Rpb25zIGRyeSB0eXBlIDYiLCAiVEwtTFRMLVBSRC1QTFQ0LUdMWjYiOiAiVW5rbm93biBBc3NldCIsICIxMDAyOTUiOiAiU3VyZmFjZSBzY3JhcGVyIG1hY2hpbmUiLCAiMTAwMjk2IjogIlNwYWNlciIsICIxMDAyOTciOiAiQnJ1c2ggYW5kIFN1Y3Rpb24iLCAiMTAwMjk4IjogIkJydXNoIGFuZCBTdWN0aW9uIiwgIjEwMDI5OSI6ICJCbG93ZXIiLCAiMTAwMzAwIjogIkFpcmxlc3Mgd2F0ZXIgc3ByYXkgbWFjaGluZSBMNi0gMSIsICIxMDAzMDEiOiAiQWlybGVzcyB3YXRlciBzcHJheSBtYWNoaW5lIEw2LSAyIiwgIjEwMDMwMiI6ICJTcHJheSBjYWJpbnMiLCAiMTAwMzAzIjogInZlbGEgbWFjaGluZXMgTDYgLTEiLCAiMTAwMzA0IjogInZlbGEgbWFjaGluZXMgTDYgLTIiLCAiMTAwMzA1IjogInZlbGEgbWFjaGluZXMgTDYgLTMiLCAiMTAwMzA2IjogIkdsYXppbmcgdHVicyBMNi0xKHR1YiB3aXRoIGFnaXRhdG9yKSIsICIxMDAzMDciOiAiR2xhemluZyB0dWJzIEw2LTIgKHR1YiB3aXRoIGFnaXRhdG9yKSIsICIxMDAzMDgiOiAiR2xhemluZyB0dWJzIEw2LTMgKHR1YiB3aXRoIGFnaXRhdG9yKSIsICIxMDAzMDkiOiAiR2xhemluZyB0dWJzIEw2LTQgKHR1YiB3aXRoIGFnaXRhdG9yKSIsICIxMDAzMTAiOiAiR2xhemluZyB0dWJzIEw2LTUgKHR1YiB3aXRoIGFnaXRhdG9yKSIsICIxMDAzMTEiOiAiVmlicmF0aW5nIHNpZXZlIiwgIjEwMDMxMiI6ICJWZXJ0aWNhbCBwdW1wcyAoc21hbGwgKUw2LTAxIiwgIjEwMDMxMyI6ICJWZXJ0aWNhbCBwdW1wcyAoc21hbGwgKUw2LTAyIiwgIjEwMDMxNCI6ICJWZXJ0aWNhbCBwdW1wcyAoc21hbGwgKUw2LTAzIiwgIjEwMDMxNSI6ICJWZXJ0aWNhbCBwdW1wcyAoc21hbGwgKUw2LTA0IiwgIjEwMDMxNiI6ICJWZXJ0aWNhbCBwdW1wcyAoIGxhcmdlKUw2LTAxIiwgIjEwMDMxNyI6ICJUaWxlIFR1cm5lciAgYmVkIEw2IC0gMDEiLCAiMTAwMzE4IjogIlRpbGUgVHVybmVyICBiZWQgTDYgLSAwMiIsICIxMDAzMTkiOiAiVGlsZSBUdXJuZXIgIGJlZCBMNiAtIDAzIiwgIjEwMDMyMCI6ICJXZXQgc2NyYXBlciBMNi0xIiwgIjEwMDMyMSI6ICJXZXQgc2NyYXBlciBMNi0yIiwgIjEwMDMyMiI6ICJCbG93ZXJzIiwgIjEwMDMyMyI6ICJUaWxlIENvb2xlciIsICIxMDAzMjQiOiAiRGlnaXRhbCBtYWNoaW5lIiwgIjEwMDMyNSI6ICJEcnkgR2xhemUgTWFjaGluZSArIHN1Y3Rpb24gbWFjaGluZSIsICIxMDAzMjYiOiAiSVIgbGlnaHQgU3lzdGVtIEw2LTEiLCAiMTAwMzI3IjogIklSIGxpZ2h0IFN5c3RlbSBMNi0yIiwgIjEwMDMyOCI6ICJEcm9wIGNhYmluIiwgIjEwMDMyOSI6ICJEYW1hZ2UgcmVtb3ZpbmcgbWFjaGluZSIsICIxMDAzMzAiOiAiU3RlcCBieSBzdGVwIGJlbHQiLCAiMTAwMzMxIjogIlJvbGxlcm1hdGljIG1hY2hpbmUiLCAiMTAwMzMyIjogIkxHViBtYWNoaW5lcyAwMSIsICIxMDAzMzMiOiAiTEdWIG1hY2hpbmVzIDAyIiwgIjEwMDMzNCI6ICJMR1YgcGFuZWwiLCAiMTAwMzM1IjogIlByZSBEcnllciIsICIxMDA0NjciOiAibGluZSBjb252ZXlvciAtIDYiLCAiMjAwMDcwIjogIkxpbmUgMDYgQUMgMDEiLCAiMjAwMDcxIjogIkxpbmUgMDYgQUMgMDIiLCAiVEwtTFRMLVBSRC1QTFQ0LUtJTE4iOiAiVW5rbm93biBBc3NldCIsICIxMDAzMzYiOiAiS2lsbiA1IFJvbGxlcm1hdGljIG1hY2hpbmUiLCAiMTAwMzM3IjogIktpbG4gNSBGZWVkaW5nIFJvbGxlciBiZWRzIiwgIjEwMDMzOCI6ICJraWxuIDUiLCAiMTAwMzM5IjogIktpbG4gMDUgU3RhbmRieSBnZW5hdGF0b3IiLCAiMTAwMzQwIjogIktpbG4gNSBleGl0IGNvbnZleW9ycyIsICIxMDAzNDEiOiAiS2lsbiA1IENvbnRhaW5lciBsb2FkaW5nIE1hY2hpbmUiLCAiMjAwMDcyIjogIktpbG4gcm9vbTUiLCAiVEwtTFRMLVBSRC1QTFQ0LVBSRTYiOiAiVW5rbm93biBBc3NldCIsICIxMDAyODAiOiAiUHJlc3MgNiIsICIxMDAyODEiOiAiUHJlc3MgRmVlZGVyKERDTCkiLCAiMTAwMjgyIjogIkFDUCIsICIxMDAyODMiOiAiQUxNIiwgIjEwMDI4NCI6ICJwcmVzcyAwNiBwYW5lbCBBQyIsICIxMDAyODUiOiAiUHJlc3MgMDYgbWFjaGluZSBwYW5lbCBBQyIsICIxMDAyODYiOiAiUHJlc3MgY29vbGluZyBtYWNoaW5lICBMNiIsICIxMDAyODciOiAiUHJlc3MgZXhpdCBjb252ZXllcnMiLCAiMTAwMjg4IjogIlRpbGUgYm90dG9tIHNpZGUgc2NyYXBlciBicnVzaCIsICIxMDAyODkiOiAiVGlsZSBUdXJuZXIgKFJQUikiLCAiMTAwMjkwIjogIlRpbGUgc3VyZmFjZSBzY3JhcGVyIGJydXNoIiwgIlRMLUxUTC1QUkQtUExUNC1WRFJZIjogIlVua25vd24gQXNzZXQiLCAiMTAwMjkxIjogIk11bHRpcGxpZXIgY29udmV5b3IiLCAiMTAwMjkyIjogIlJvbGxlciBiZWQiLCAiMTAwMjkzIjogIlZlcnRpY2FsIERyeWVyIiwgIjEwMDI5NCI6ICJWZXJ0aWNhbCBkcnllciAwNiBwYW5lbCBBQyIsICJUTC1MVEwtUFJELVBPU0giOiAiUE9MSVNISU5HIiwgIjEwMDQ0NCI6ICJDb250YWluZXIgVW5sb2FkaW5nIiwgIjEwMDQ0NSI6ICIgUE9MSVNISU5HIE1BQ0hJTkUiLCAiMTAwNDQ2IjogIkNvbnRhaW5lciBVbmxvYWRpbmciLCAiMTAwNDQ3IjogIkNvbnRhaW5lciBVbmxvYWRpbmcgIFBhbmVsIEFDIiwgIlRMLUxUTC1QUkQtUE9TSC1MSU4xIjogIlVua25vd24gQXNzZXQiLCAiVEwtTFRMLVBSRC1QUFAxIjogIlBPV0RFUiBQUkVQRVJBVElPTiBQTEFOVCAxIiwgIjIwMDA2MCI6ICJNaWxsaW5nIERlcC4gb2ZmaWNlIiwgIjIwMDA2MSI6ICJDeWxpbmRlciByb29tIGFjIDAxIiwgIjIwMDA2MiI6ICJDeWxpbmRlciByb29tIGFjIDAyIiwgIlRMLUxUTC1QUkQtUFBQMS1CTUxEIjogIlVua25vd24gQXNzZXQiLCAiMTAwMDAwIjogIkhvcHBlciBTY2FsZSAwMSIsICIxMDAwMDQiOiAiQmFsbCBtaWxsIEZlZWRpbmcgY29udmV5b3Igc3lzdGVtLVMxIiwgIjIwMDAxMCI6ICJEdXN0IHN1Y3Rpb25zIGRyeSB0eXBlIDEiLCAiVEwtTFRMLVBSRC1QUFAxLU1JTEwiOiAiVW5rbm93biBBc3NldCIsICIxMDAwMDgiOiAiQmFsbCBNaWxsIDEiLCAiMTAwMDA5IjogIkJhbGwgTWlsbCAyIiwgIjEwMDAxMCI6ICJCYWxsIE1pbGwgMyIsICIxMDAwMTEiOiAiQmFsbCBNaWxsIDQiLCAiMTAwMDEyIjogIkJhbGwgTWlsbCA1IiwgIlRMLUxUTC1QUkQtUFBQMS1TRFJZIjogIlVua25vd24gQXNzZXQiLCAiMTAwMDY5IjogIlBvd2RlciBjb252ZXlvcnMiLCAiVEwtTFRMLVBSRC1QUFAxLVNMUFAiOiAiVW5rbm93biBBc3NldCIsICIxMDAwMjIiOiAiVmlicmF0aW5nIFNlaXZlIC1QbGFudCAwMS1BIFQiLCAiMTAwMDIzIjogIlZpYnJhdGluZyBTZWl2ZSAtUGxhbnQgMDEtQiAgVCIsICIxMDAwMjQiOiAiVmlicmF0aW5nIFNlaXZlIC1QbGFudCAwMS1DICBUIiwgIlRMLUxUTC1QUkQtUFBQMiI6ICJQT1dERVIgUFJFUEVSQVRJT04gUExBTlQgMiIsICJUTC1MVEwtUFJELVBQUDItQk1MRCI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDAwMSI6ICJIb3BwZXIgU2NhbGUtMDIiLCAiMTAwMDA1IjogIkJhbGwgbWlsbCBGZWVkaW5nIGNvbnZleW9yIHN5c3RlbS1TMiIsICJUTC1MVEwtUFJELVBQUDItTUlMTCI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDAxMyI6ICJCYWxsIE1pbGwgNiIsICIxMDAwMTQiOiAiQmFsbCBNaWxsIDciLCAiMTAwMDE1IjogIkJhbGwgTWlsbCA4IiwgIjEwMDAxNiI6ICJCYWxsIE1pbGwgOSIsICIxMDAwMTciOiAiQmFsbCBNaWxsIDEwIiwgIjEwMDAxOCI6ICJCYWxsIE1pbGwgMTAgcGFuZWwgQUMiLCAiMTAwMDE5IjogIkJhbGwgTWlsbCAxMSIsICIxMDAwMjAiOiAiQmFsbCBNaWxsIDExIHBhbmVsIEFDIiwgIlRMLUxUTC1QUkQtUFBQMi1TRFJZIjogIlVua25vd24gQXNzZXQiLCAiMTAwMDYwIjogIlBpc3RvbiBQdW1wIiwgIjEwMDA2MSI6ICJQaXN0b24gUHVtcCIsICIxMDAwNjUiOiAiU3ByYXkgZHJ5ZXIgMiIsICIxMDAwNjYiOiAiU3ByYXkgRHJ5ZXIgMDIgcGFuZWwgQUMiLCAiMTAwMDcwIjogIlZpYnJhdGluZyBzY3JlZW4gOSIsICIxMDAwNzIiOiAiQnVja2V0IGVsZXZhdG9yIDEiLCAiMTAwNDYyIjogIkR1c3Qgc3VjdGlvbnMgd2V0IHR5cGUgMSIsICJUTC1MVEwtUFJELVBQUDItU0xQUCI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDAyNSI6ICJWaWJyYXRpbmcgU2VpdmUgLVBsYW50IDAyLUEgIFQiLCAiMTAwMDI2IjogIlZpYnJhdGluZyBTZWl2ZSAtUGxhbnQgMDItQiAgVCIsICIxMDAwMjciOiAiVmlicmF0aW5nIFNlaXZlIC1QbGFudCAwMi1DICBUIiwgIjEwMDAzNSI6ICJTbGlwIHRhbmsgMDYgKEJsYWRlIHN0aXJyZXItMDEpIiwgIjEwMDAzNiI6ICJTbGlwIHRhbmsgMDcgKEJsYWRlIHN0aXJyZXItMDEpIiwgIjEwMDAzNyI6ICJTbGlwIHRhbmsgMDggKEJsYWRlIHN0aXJyZXItMDEpIiwgIjEwMDAzOCI6ICJTbGlwIHRhbmsgMDkgKEJsYWRlIHN0aXJyZXItMDEpIiwgIjEwMDAzOSI6ICJTbGlwIHRhbmsgMTAgKEJsYWRlIHN0aXJyZXItMDEpIiwgIjEwMDA0NSI6ICJTbGlwIHRhbmsgMDYgKEJsYWRlIHN0aXJyZXItMDIpIiwgIjEwMDA0NiI6ICJTbGlwIHRhbmsgMDcgKEJsYWRlIHN0aXJyZXItMDIpIiwgIjEwMDA0NyI6ICJTbGlwIHRhbmsgMDggKEJsYWRlIHN0aXJyZXItMDIpIiwgIjEwMDA0OCI6ICJTbGlwIHRhbmsgMDkgKEJsYWRlIHN0aXJyZXItMDIpIiwgIjEwMDA0OSI6ICJTbGlwIHRhbmsgMTAgKEJsYWRlIHN0aXJyZXItMDIpIiwgIjEwMDA1MCI6ICJWaWJyYXRpbmcgc2NyZWVuIDEiLCAiMTAwMDUxIjogIlZpYnJhdGluZyBzY3JlZW4gMiIsICIxMDAwNTIiOiAiVmlicmF0aW5nIHNjcmVlbiAzIiwgIjEwMDA1MyI6ICJWaWJyYXRpbmcgc2NyZWVuIDQiLCAiMTAwMDU4IjogIklyb24gUmVtb3ZlciAxIiwgIlRMLUxUTC1QUkQtUFBQMyI6ICJQT1dERVIgUFJFUEVSQVRJT04gUExBTlQgMyIsICJUTC1MVEwtUFJELVBQUDMtQk1MRCI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDAwMiI6ICJIb3BwZXIgQXV0byBTY2FsZS0wMyIsICIxMDAwMDMiOiAiSG9wcGVyIENoaW5hIFNhY2xlLTA0IiwgIjEwMDAwNiI6ICJCYWxsIG1pbGwgRmVlZGluZyBjb252ZXlvciBzeXN0ZW0tUzMiLCAiMTAwMDA3IjogIkJhbGwgbWlsbCBGZWVkaW5nIGNvbnZleW9yIHN5c3RlbS1TNCIsICIyMDAwMTEiOiAiRHVzdCBzdWN0aW9ucyBkcnkgdHlwZSAyIiwgIlRMLUxUTC1QUkQtUFBQMy1NSUxMIjogIlVua25vd24gQXNzZXQiLCAiMTAwMDIxIjogIkJhbGwgTWlsbCAxMiIsICJUTC1MVEwtUFJELVBQUDMtU0RSWSI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDA2MiI6ICJQaXN0b24gUHVtcCIsICIxMDAwNjMiOiAiUGlzdG9uIFB1bXAiLCAiMTAwMDY0IjogIlBpc3RvbiBQdW1wIiwgIjEwMDA2NyI6ICJTcHJheSBkcnllciAzIiwgIjEwMDA2OCI6ICJTcHJheSBEcnllciAwMyBwYW5lbCBBQyIsICIxMDAwNzEiOiAiVmlicmF0aW5nIHNjcmVlbiAxMCIsICIxMDAwNzMiOiAiQnVja2V0IGVsZXZhdG9yIDIiLCAiMTAwNDYzIjogIkR1c3Qgc3VjdGlvbnMgd2V0IHR5cGUgMiIsICJUTC1MVEwtUFJELVBQUDMtU0xQUCI6ICJVbmtub3duIEFzc2V0IiwgIjEwMDAyOCI6ICJWaWJyYXRpbmcgU2VpdmUgLVBsYW50IDAzLUEgIFQiLCAiMTAwMDI5IjogIlZpYnJhdGluZyBTZWl2ZSAtUGxhbnQgMDMtQiAgVCIsICIxMDAwMzAiOiAiU2xpcCB0YW5rIDAxIChCbGFkZSBzdGlycmVyLTAxKSIsICIxMDAwMzEiOiAiU2xpcCB0YW5rIDAyIChCbGFkZSBzdGlycmVyLTAxKSIsICIxMDAwMzIiOiAiU2xpcCB0YW5rIDAzIChCbGFkZSBzdGlycmVyLTAxKSIsICIxMDAwMzMiOiAiU2xpcCB0YW5rIDA0IChCbGFkZSBzdGlycmVyLTAxKSIsICIxMDAwMzQiOiAiU2xpcCB0YW5rIDA1IChCbGFkZSBzdGlycmVyLTAxKSIsICIxMDAwNDAiOiAiU2xpcCB0YW5rIDAxIChCbGFkZSBzdGlycmVyLTAyKSIsICIxMDAwNDEiOiAiU2xpcCB0YW5rIDAyIChCbGFkZSBzdGlycmVyLTAyKSIsICIxMDAwNDIiOiAiU2xpcCB0YW5rIDAzIChCbGFkZSBzdGlycmVyLTAyKSIsICIxMDAwNDMiOiAiU2xpcCB0YW5rIDA0IChCbGFkZSBzdGlycmVyLTAyKSIsICIxMDAwNDQiOiAiU2xpcCB0YW5rIDA1IChCbGFkZSBzdGlycmVyLTAyKSIsICIxMDAwNTQiOiAiVmlicmF0aW5nIHNjcmVlbiA1IiwgIjEwMDA1NSI6ICJWaWJyYXRpbmcgc2NyZWVuIDYiLCAiMTAwMDU2IjogIlZpYnJhdGluZyBzY3JlZW4gNyIsICIxMDAwNTciOiAiVmlicmF0aW5nIHNjcmVlbiA4IiwgIjEwMDA1OSI6ICJJcm9uIFJlbW92ZXIgMiIsICJUTC1MVEwtUFJELVNPUlQtTElOMSI6ICJTT1JUSU5HIExJTkUxIiwgIjEwMDM5NiI6ICJDb250YWluZXIgVW5sb2FkaW5nIChzb3J0aW5nIGZlZWRpbmcpIiwgIjEwMDM5NyI6ICJTb3J0ZXIgYmVuY2giLCAiMTAwMzk4IjogIlJlZCBsaW5lciIsICIxMDAzOTkiOiAic29ydGluZyBtYWNoaW5lIiwgIjEwMDQwMCI6ICJ3cmFwcGluZyBtYWNoaW5lIiwgIjIwMDA0NiI6ICJTb3J0aW5nIGNvbXB1dGVyIHJvb20iLCAiMjAwMDQ4IjogIkNvbSByb29tIHNvcnRpbmcgZGVwdCAwMSIsICJUTC1MVEwtUFJELVNPUlQtTElOMiI6ICJTT1JUSU5HIExJTkUyIiwgIjEwMDQwMSI6ICJDb250YWluZXIgVW5sb2FkaW5nIChzb3J0aW5nIGZlZWRpbmcgKSIsICIxMDA0MDIiOiAiU29ydGVyIGJlbmNoIiwgIjEwMDQwMyI6ICJSZWQgbGluZXIiLCAiMTAwNDA0IjogInNvcnRpbmcgbWFjaGluZSIsICIxMDA0MDUiOiAid3JhcHBpbmcgbWFjaGluZSIsICJUTC1MVEwtUFJELVNPUlQtTElOMyI6ICJTT1JUSU5HIExJTkUzIiwgIjEwMDQwNiI6ICJDb250YWluZXIgVW5sb2FkaW5nIChzb3J0aW5nIGZlZWRpbmcgKSIsICIxMDA0MDciOiAiU29ydGVyIGJlbmNoIiwgIjEwMDQwOCI6ICJSZWQgbGluZXIiLCAiMTAwNDA5IjogIlBsYW5uZXIgR2F1Z2UiLCAiMTAwNDEwIjogInNvcnRpbmcgbWFjaGluZSIsICIxMDA0MTEiOiAiU29ydGluZyAwMyAgbWFjaGluZSBwYW5lbCBBQyIsICIxMDA0MTIiOiAid3JhcHBpbmcgbWFjaGluZSIsICIxMDA0MTMiOiAiU29ydGluZyAwMyB3cmFwcGluZyBtYWNoaW5lIHBhbmVsIEFDIiwgIjUwMDAwMCI6ICJTT1JUIDAzIEFVVE8gU1RSQVBQSU5HIFRPT0wgIDAxIiwgIjUwMDAwMSI6ICJTT1JUIDAzIEFVVE8gU1RSQVBQSU5HIFRPT0wgIDAyIiwgIjUwMDAwNSI6ICJTT1JUIDAzIFN0cmFwcGluZyB0b29sICYgU2VhbGVyIDAxIiwgIjUwMDAwNiI6ICJTT1JUIDAzIFN0cmFwcGluZyB0b29sICYgU2VhbGVyIDAyIiwgIlRMLUxUTC1QUkQtU09SVC1MSU41IjogIlNPUlRJTkcgTElORTUiLCAiMTAwNDE0IjogIkNvbnRhaW5lciBVbmxvYWRpbmciLCAiMTAwNDE1IjogIlF1YWxpdHJvbiAgbWFjaGluZSIsICIxMDA0MTYiOiAiU29ydGVyIGJlbmNoIiwgIjEwMDQxNyI6ICJSZWQgbGluZXIiLCAiMTAwNDE4IjogIlBsYW5uZXIgR2F1Z2UiLCAiMTAwNDE5IjogIlNvcnRpbmUgbWFjaGluZSIsICIxMDA0MjAiOiAiU29ydGluZyAwNSBsb2FkaW5nIG1hY2hpbmUgcGFuZWwgQUMiLCAiMTAwNDIxIjogIndyYXBwaW5nIG1hY2hpbmUoQ1BLIChzb3J0aW5nIDA1ICkpIiwgIjEwMDQyMiI6ICJTb3J0aW5nIDA1IHdyYXBwaW5nIG1hY2hpbmUgcGFuZWwgQUMiLCAiMTAwNDIzIjogIlBhbGxldGl6ZXIiLCAiNTAwMDAyIjogIlNPUlQgMDUgQVVUTyBTVFJBUFBJTkcgVE9PTCAgMDEiLCAiNTAwMDAzIjogIlNPUlQgMDUgQVVUTyBTVFJBUFBJTkcgVE9PTCAgMDIiLCAiNTAwMDA0IjogIlNPUlQgMDUgQVVUTyBTVFJBUFBJTkcgVE9PTCAgMDMiLCAiNTAwMDA3IjogIlNPUlQgMDUgU3RyYXBwaW5nIHRvb2wgJiBTZWFsZXIgMDEiLCAiNTAwMDA4IjogIlNPUlQgMDUgU3RyYXBwaW5nIHRvb2wgJiBTZWFsZXIgMDIiLCAiVEwtTFRMLVBSRC1TT1JULUxJTjYiOiAiU09SVElORyBMSU5FNiIsICIxMDA0MjQiOiAiQ29udGFpbmVyIGxvYWRpbmciLCAiMTAwNDI1IjogIkNvbnRhaW5lciBsb2FkaW5nIHBhbmVsIEFDIiwgIjEwMDQyNiI6ICJDb250YWluZXIgVW5sb2FkaW5nIiwgIjEwMDQyNyI6ICJDb250YWluZXIgVW5sb2FkaW5nIHBhbmVsIEFDIiwgIjEwMDQyOCI6ICJTb3J0ZXIgYmVuY2giLCAiMTAwNDI5IjogInJlZCBsaW5lYXIiLCAiMTAwNDMwIjogIlBsYW5uZXIgR2F1Z2UiLCAiMTAwNDMxIjogInNvcnRpbmcgbWFjaGluZShtdWx0aWdlY2hvKSIsICIxMDA0MzIiOiAiU29ydGluZyAwNiAoTVVMVElHRUNLTykgcGFuZWwgQUMiLCAiMTAwNDMzIjogIndyYXBwaW5nIG1hY2hpbmUoQ1BLIHBhY2tpbmcpIiwgIjEwMDQzNCI6ICJXcmFwcGluZyAoQlMwOCkgcGFuZWwgQUMiLCAiMTAwNDM1IjogIlBBTExFVElaRVIiLCAiMTAwNDM2IjogIkZBTENPTiBwYW5lbCBBQyIsICI1MDAwMDkiOiAiU09SVCAwNiBBVVRPIFNUUkFQUElORyBUT09MIDAxIiwgIjUwMDAxMCI6ICJTT1JUIDA2IEFVVE8gU1RSQVBQSU5HIFRPT0wgMDIiLCAiNTAwMDExIjogIlNPUlQgMDYgQVVUTyBTVFJBUFBJTkcgVE9PTCAwMyIsICJUTC1MVEwtUFJELVNPUlQtTElONyI6ICJTT1JUSU5HIExJTkU3IiwgIjEwMTQ5MyI6ICJTb3J0ZXIgYmVuY2giLCAiMTAxNDk0IjogInJlZCBsaW5lYXIiLCAiMTAxNDk1IjogIlBsYW5uZXIgR2F1Z2UiLCAiMTAxNDk2IjogInNvcnRpbmcgbWFjaGluZShtdWx0aWdlY2hvKSIsICIxMDE0OTciOiAiU29ydGluZyAwNyAoTVVMVElHRUNLTykgcGFuZWwgQUMiLCAiMTAxNDk4IjogIndyYXBwaW5nIG1hY2hpbmUoTXVsdGlwYWNrKSIsICIxMDE0OTkiOiAiV3JhcHBpbmcgKG11bHRpcGFjaykgcGFuZWwgQUMiLCAiMTAxNTAxIjogIlBBTExFVElaRVIiLCAiMTAxNTAyIjogIlBBTExFVElaRVIgcGFuZWwgQUMiLCAiVEwtTFRMLVBSRC1TUFJKIjogIlNQRUNJQUwgUFJPSkVDVFMiLCAiVEwtTFRMLVBSRC1TUFJKLUNVVFQiOiAiVW5rbm93biBBc3NldCIsICJUTC1MVEwtUFJELVNQUkotV1RQTCI6ICJVbmtub3duIEFzc2V0IiwgIjIwMDA4MiI6ICJGaWx0ZXIgcHJlc3MgMDEiLCAiMjAwNDY4IjogIldhdGVyIFRyZWF0bWVudCBQbGFudCAwMSIsICJUTC1MVEwtUUFEIjogIlFVQUxJVFkgQVNTVVJFTUNFIERFUFQiLCAiVEwtTFRMLVFBRC1MQUJPIjogIkxBQk9SQVRPUlkiLCAiMTAwNDU1IjogIkxhYiBwcmVzcyIsICIxMDA0NTYiOiAiRy5ULlN0cmVuZ3RoIG1hY2hpbmUgMSIsICIxMDA0NTciOiAiRy5ULlN0cmVuZ3RoIG1hY2hpbmUgMiIsICIyMDAwNjYiOiAiTGFiIGN1YmljYWwgcm9vbSBhYyAwMSIsICIyMDAwNjciOiAiTGFiIGN1YmljYWwgcm9vbSBhYyAwMiIsICIzMDAwMDAiOiAiRy5ULlN0cmVuZ3RoIG1hY2hpbmUgMyIsICIzMDAwMDEiOiAiQWJyYXNpbWV0ZXIiLCAiMzAwMDAyIjogIkxhYiBEcnllciAxIiwgIjMwMDAwMyI6ICJMYWIgRHJ5ZXIgMiIsICIzMDAwMDQiOiAiTWl4dHVyZSIsICIzMDAwMDUiOiAidmlicmF0aW5nIHNpZXZlIiwgIjMwMDAwNiI6ICJWYWNjdW0gd2F0ZXIgYWJzb3JwdGlvbiB0YW5rIiwgIjMwMDAwNyI6ICJKYXIgbWlsbCBzaGFrZXIiLCAiMzAwMDA4IjogIkZhc3QgbWlsbCBRQSIsICIzMDAwMDkiOiAiRmFzdCBtaWxsIFImRCIsICIzMDAwMTAiOiAiU3ByYXkgY2FiaW4gMSIsICIzMDAwMTEiOiAiU3ByYXkgY2FiaW4gMiIsICIzMDAwMTIiOiAiRi5ULiBTVFJFTkdUSCBNQUNISU5FIiwgIjMwMDAxMyI6ICJMYWJvcmF0b3J5IG11ZmZsZSBraWxuIiwgIjMwMDAxNCI6ICJBdXRvIGNsYXZlIiwgIjMwMDAxNSI6ICJTY2FsZSAxIiwgIjMwMDAxNiI6ICJTY2FsZSAyIiwgIjMwMDAxNyI6ICJTY2FsZSAzIiwgIjMwMDAxOCI6ICJTY2FsZSA0IiwgIjMwMDAxOSI6ICJESUxBVE9NRVRFUiIsICIzMDAwMjAiOiAiTU9JU1RVUkUgQkFMQU5DRSIsICIzMDAwMjEiOiAiV2V0IHBlbmR1bHVtIiwgIlRMLUxUTC1RQUQtTUNORCI6ICJNRVJDSEFORElaSU5HIiwgIlRMLUxUTC1RQUQtUVVBUyI6ICJRVUFMSVRZIEFTU1VSRU5DRSIsICIzMDAwNjEiOiAiQ2FsaXBlci1EaWdpdGFsLUYuRC5TIEVUVE1BUiAxIiwgIjMwMDA2MiI6ICJDYWxpcGVyLSAyIiwgIjMwMDA2MyI6ICJDYWxpcGVyLSAzIiwgIjMwMDA2NCI6ICJDYWxpcGVyLSA0IiwgIjMwMDA2NSI6ICJDYWxpcGVyLSA1IiwgIjMwMDA2NiI6ICJDYWxpcGVyLSA2IiwgIjMwMDA2NyI6ICJDYWxpcGVyLSA3IiwgIjMwMDA2OCI6ICJDYWxpcGVyLSA4IiwgIjMwMDA2OSI6ICJDYWxpcGVyLSA5IiwgIjMwMDA3MCI6ICJDYWxpcGVyLSAxMCIsICIzMDAwNzEiOiAiQ2FsaXBlci0gMTEiLCAiMzAwMDcyIjogIkNhbGlwZXItRGlnaXRhbC1GLkQuUyBFVFRNQVIgMTIiLCAiMzAwMDczIjogIkNhbGlwZXItIDEzIiwgIjMwMDA3NCI6ICJDYWxpcGVyLSAxNCIsICIzMDAwNzUiOiAiQ2FsaXBlci0gMTUiLCAiMzAwMDc2IjogIkNhbGlwZXItIDE2IiwgIjMwMDA3NyI6ICJDYWxpcGVyLSAxNyIsICIzMDAwNzgiOiAiQ2FsaXBlci1EaWdpdGFsLUYuRC5TIEVUVE1BUiAxOCIsICIzMDAwNzkiOiAiQ2FsaXBlci0gMTkiLCAiMzAwMDgwIjogIkNhbGlwZXItIDIwIiwgIjMwMDA4MSI6ICJDYWxpcGVyLSAyMSIsICIzMDAwODIiOiAiRk9SRENVUC0gMSIsICIzMDAwODMiOiAiRk9SRENVUC0gMiIsICIzMDAwODQiOiAiRk9SRENVUC0gMyIsICIzMDAwODUiOiAiRk9SRENVUC0gNCIsICIzMDAwODYiOiAiRk9SRENVUC0gNSIsICIzMDAwODciOiAiRk9SRENVUC0gNiIsICIzMDAwODgiOiAiRk9SRENVUC0gNyIsICIzMDAwODkiOiAiRk9SRENVUC0gOCIsICIzMDAwOTAiOiAiRk9SRENVUC0gOSIsICIzMDAwOTEiOiAiUFlLTk9NRVRFUi0gMSIsICIzMDAwOTIiOiAiUFlLTk9NRVRFUi0gMiIsICIzMDAwOTMiOiAiUFlLTk9NRVRFUi0gMyIsICIzMDAwOTQiOiAiUFlLTk9NRVRFUi0gNCIsICIzMDAwOTUiOiAiUFlLTk9NRVRFUi0gNSIsICIzMDAwOTYiOiAiUFlLTk9NRVRFUi0gNiIsICIzMDAwOTciOiAiUFlLTk9NRVRFUi0gNyIsICIzMDAwOTgiOiAiUFlLTk9NRVRFUi0gOCIsICIzMDAwOTkiOiAiUFlLTk9NRVRFUi0gOSIsICIzMDAxMDAiOiAiUFlLTk9NRVRFUi0gMTAiLCAiMzAwMTAxIjogIlNDQUxFUy0gMSIsICIzMDAxMDIiOiAiU0NBTEVTLSAyIiwgIjMwMDEwMyI6ICJTQ0FMRVMtIDMiLCAiMzAwMTA0IjogIlNDQUxFUy0gNCIsICIzMDAxMDUiOiAiU0NBTEVTLSA1IiwgIjMwMDEwNiI6ICJTQ0FMRVMtIDYiLCAiMzAwMTA3IjogIlNDQUxFUy0gNyIsICIzMDAxMDgiOiAiU0NBTEVTLSA4IiwgIjMwMDEwOSI6ICJTQ0FMRVMtIDkiLCAiMzAwMTEwIjogIlNDQUxFUy0gMTAiLCAiMzAwMTExIjogIlNDQUxFUy0gMTEiLCAiMzAwMTEyIjogIlNDQUxFUy0gMTIiLCAiMzAwMTEzIjogIlNDQUxFUy0gMTMiLCAiMzAwMTE0IjogIlNDQUxFUy0gMTQiLCAiMzAwMTE1IjogIlNDQUxFUy0gMTUiLCAiMzAwMTE2IjogIlNDQUxFUy0gMTYiLCAiMzAwMTE3IjogIlNDQUxFUy0gMTciLCAiMzAwMTE4IjogIlNDQUxFUy0gMTgiLCAiMzAwMTE5IjogIlNDQUxFUy0gMTkiLCAiMzAwMTIwIjogIlNDQUxFUy0gMjAiLCAiMzAwMTIxIjogIlNDQUxFUy0gMjEiLCAiVEwtTFRMLVFBRC1STkQiOiAiUkVTRUFSQ0ggQU5EIERFVkVMT1BNRU5UIiwgIjIwMDA2NCI6ICJEZXNpZ24gZGVwYXJ0bWVudCIsICJUTC1MVEwtU1RSIjogIlNUT1JFUyIsICJUTC1MVEwtU1RSLUJJV0giOiAiQklZQUdBTUEgVy9IIiwgIlRMLUxUTC1TVFItQk1XSCI6ICJCQUxVTU1BSEFSQSBXL0giLCAiVEwtTFRMLVNUUi1GR1NUIjogIkZJTklTSEVEIEdPT0RTIFNUT1JFUyIsICIyMDAwNTgiOiAiRmluaXNoZWQgZ29vZHMgc3RvcmVzIiwgIjIwMDA3MyI6ICJGaW5pc2ggZ29vZCBvZmZpY2UgMiIsICJUTC1MVEwtU1RSLUdTVFIiOiAiR0VORVJBTCBTVE9SRVMiLCAiMjAwMDQxIjogIkRpZ2l0YWwgaW5rIHJvb20iLCAiMjAwMDQyIjogIlB1bmNoZXJzIHJvb20iLCAiMjAwMDY4IjogIkdlbmVyYWwgc3RvcmVzIiwgIlRMLUxUTC1TVFItTkFXSCI6ICJOQVdBTEEgVy9IIiwgIlRMLUxUTC1TVFItTkhXSCI6ICJOQVJBSEVOUElUQSBXL0gifQ=="

    if encoded_data:
        ITEM_DB = json.loads(base64.b64decode(encoded_data).decode())
    else:
        ITEM_DB = {}
except Exception:
    ITEM_DB = {}

st.set_page_config(layout="wide", page_title="Maintenance Analyzer Lankatile PLC", page_icon="üè≠")

# --- CSS STYLING ---
st.markdown("""
    <style>
        .main { background-color: #f8f9fa; }
        .watermark {
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 6px 10px;
            border-radius: 6px;
            display: inline-block;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            background: rgba(255,255,255,0.85);
            color: #111;
            font-family: 'Courier New', monospace;
        }
        @media (prefers-color-scheme: dark) {
            .watermark {
                background: rgba(0,0,0,0.75);
                color: #fff;
                box-shadow: 0 2px 6px rgba(255,255,255,0.03);
            }
        }
        .logo-container { 
            text-align: center; margin-bottom: 20px;
            padding: 15px; background: white; border-radius: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .metric-card {
            background-color: white; padding: 15px; border-radius: 10px;
            border-left: 5px solid #3498db; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .ai-banner {
            background: linear-gradient(90deg,#0ea5a4,#06b6d4);
            color: white;
            padding: 14px;
            border-radius: 10px;
            font-weight: 700;
            margin-bottom: 18px;
            text-align: center;
        }
    </style>
""", unsafe_allow_html=True)

# --- PDF GENERATOR ---
class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 15)
        self.cell(0, 10, 'Maintenance Analyzer Report', 0, 1, 'C')
        self.ln(5)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

def generate_pdf(df):
    pdf = PDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    act = df['TotSum (actual)'].sum() if 'TotSum (actual)' in df.columns else 0
    plan = df['TotSum (plan)'].sum() if 'TotSum (plan)' in df.columns else 0
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "1. Financial Summary", 0, 1)
    pdf.set_font("Arial", size=12)
    pdf.cell(0, 10, f"Total Actual Cost: LKR {act:,.2f}", 0, 1)
    pdf.cell(0, 10, f"Total Planned Cost: LKR {plan:,.2f}", 0, 1)
    pdf.cell(0, 10, f"Variance: LKR {act-plan:,.2f}", 0, 1)
    pdf.ln(5)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "2. Top 5 Costliest Assets", 0, 1)
    pdf.set_font("Arial", size=10)
    if 'Equipment description' in df.columns:
        cost = df.groupby('Equipment description')['TotSum (actual)'].sum().sort_values(ascending=False).head(5)
        for name, val in cost.items():
            clean_name = str(name).encode('latin-1', 'replace').decode('latin-1')
            pdf.cell(0, 8, f" - {clean_name}: LKR {val:,.2f}", 0, 1)
    pdf.ln(5)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_file:
        pdf.output(tmp_file.name)
        return tmp_file.name

# --- DATA LOADER ---
@st.cache_data
def load_data(files):
    all_data = []
    removed_all = []

    for idx, file in enumerate(files):
        try:
            if file.name.endswith('.csv'):
                df_raw = pd.read_csv(file)
            else:
                df_raw = pd.read_excel(file)

            df = df_raw.copy()

            for c in ['TotSum (actual)', 'TotSum (plan)', 'Order']:
                if c in df.columns:
                    df[c] = pd.to_numeric(df[c], errors='coerce').fillna(0)

            zlt_map = {
                'ZLT1': 'General maintenance',
                'ZLT2': 'Breakdown maintenance',
                'ZLT4': 'Preventive maintenance',
                'ZLT5': 'Vehicle maintenance'
            }
            if 'Order Type' in df.columns:
                df['Order Type'] = df['Order Type'].astype(str).map(zlt_map).fillna(df['Order Type'])

            if 'Main WorkCtr' in df.columns:
                df['Main WorkCtr'] = df['Main WorkCtr'].replace({
                    'MECH': 'Mechanical Dpt.', 
                    'ELEC': 'Electrical Dpt.',
                    'mech': 'Mechanical Dpt.',
                    'elec': 'Electrical Dpt.'
                })

            if 'Equipment' in df.columns:
                def clean_code(val):
                    try:
                        return str(int(float(val)))
                    except Exception:
                        return str(val).strip()
                df['Equip_Key'] = df['Equipment'].apply(clean_code)
                df['Mapped_Desc'] = df['Equip_Key'].map(ITEM_DB)
                if 'Equipment description' not in df.columns:
                    df['Equipment description'] = df['Mapped_Desc']
                else:
                    df['Equipment description'] = df['Equipment description'].fillna(df['Mapped_Desc'])
                df['Equipment description'] = df['Equipment description'].fillna("Unknown Asset")

            if 'Functional Loc.' in df.columns:
                df['Loc_Display'] = df['Functional Loc.']
            else:
                df['Loc_Display'] = ''

            if 'Location description' in df.columns:
                target_col = 'Location description'
            elif 'Description.1' in df.columns:
                target_col = 'Description.1'
            elif 'Functional Loc. Desc' in df.columns:
                target_col = 'Functional Loc. Desc'
            else:
                target_col = None

            if target_col:
                df['Loc_Display'] = df.apply(
                    lambda x: x[target_col] if (pd.notnull(x[target_col]) and str(x[target_col]) != '0') else x.get('Functional Loc.', ''),
                    axis=1
                )

            if 'Created On' in df.columns:
                df['Created_Date'] = pd.to_datetime(df['Created On'].astype(str).str.split('.').str[0], format='%Y%m%d', errors='coerce')
                df['Day_Name'] = df['Created_Date'].dt.day_name()
                df['Day_Num'] = df['Created_Date'].dt.date
                df['Month_Year'] = df['Created_Date'].dt.to_period('M')
            else:
                df['Created_Date'] = pd.NaT
                df['Day_Name'] = None
                df['Day_Num'] = None
                df['Month_Year'] = None

            if 'Bas. start date' in df.columns:
                df['Start_Date'] = pd.to_datetime(df['Bas. start date'], errors='coerce')
            else:
                df['Start_Date'] = pd.NaT

            if 'Start_Date' in df.columns and 'Created_Date' in df.columns:
                df['Response_Time'] = (df['Start_Date'] - df['Created_Date']).dt.days
                df['Response_Time'] = df['Response_Time'].fillna(0).clip(lower=0)
            else:
                df['Response_Time'] = 0

            df['Cost_Variance'] = df.get('TotSum (actual)', 0) - df.get('TotSum (plan)', 0)

            def categorize(row):
                d = str(row.get('Description', '')).lower()
                if 'pm' in d or 'preventive' in d:
                    return 'Preventive'
                return 'Corrective'
            df['Work_Type'] = df.apply(categorize, axis=1)

            df['File_Index'] = idx + 1

            neg_cols = [c for c in ['TotSum (actual)', 'TotSum (plan)', 'Order'] if c in df.columns]
            if neg_cols:
                neg_mask = pd.Series(False, index=df.index)
                for c in neg_cols:
                    neg_mask = neg_mask | (df[c] < 0)
                if neg_mask.any():
                    removed_rows = df.loc[neg_mask].copy()
                    removed_rows['Removed_Reason'] = 'Negative value in key numeric columns'
                    removed_rows['File_Index'] = idx + 1
                    removed_all.append(removed_rows)
                    df = df.loc[~neg_mask].copy()

            all_data.append(df)

        except Exception as e:
            st.error(f"Error loading {getattr(file,'name',str(idx))}: {e}")

    if all_data:
        combined = pd.concat(all_data, ignore_index=True)
    else:
        combined = None

    if removed_all:
        removed_combined = pd.concat(removed_all, ignore_index=True)
    else:
        removed_combined = None

    return combined, removed_combined

# --- DIALOGS ---
@st.dialog("üìù Machine History", width="large")
def show_machine_details(machine_name, df):
    st.markdown(f"### History for: **{machine_name}**")
    sub_df = df[df['Equipment description'] == machine_name].sort_values('Created_Date', ascending=False)
    c1, c2, c3 = st.columns(3)
    c1.metric("Total Jobs", len(sub_df))
    c2.metric("Total Cost", f"LKR {sub_df['TotSum (actual)'].sum():,.2f}" if 'TotSum (actual)' in sub_df.columns else "LKR 0.00")
    if len(sub_df) > 1:
        dates = sub_df['Created_Date'].sort_values()
        mtbf = dates.diff().dt.days.mean()
        c3.metric("MTBF", f"{mtbf:.1f} Days")
    else:
        c3.metric("MTBF", "N/A")
    st.divider()
    cols_to_show = ['Created_Date', 'Order', 'Description', 'Order Type', 'TotSum (actual)', 'User Status Text', 'Main WorkCtr']
    cols_to_show = [c for c in cols_to_show if c in sub_df.columns]
    st.dataframe(sub_df[cols_to_show], use_container_width=True, hide_index=True)

@st.dialog("üìç Location Details", width="large")
def show_location_details(loc_name, df, include_negatives=False, removed_df=None):
    st.markdown(f"### Activity at: **{loc_name}**")
    display_df = df.copy()
    if include_negatives and (removed_df is not None) and (not removed_df.empty):
        display_df = pd.concat([display_df, removed_df], ignore_index=True)
    if 'Location description' in display_df.columns:
        loc_col = 'Location description'
    else:
        loc_col = 'Loc_Display' if 'Loc_Display' in display_df.columns else 'Functional Loc.' if 'Functional Loc.' in display_df.columns else None
    if loc_col is None:
        st.write("No location column available for grouping.")
        return
    sub_df = display_df[display_df[loc_col] == loc_name].sort_values('Created_Date', ascending=False)
    c1, c2 = st.columns(2)
    c1.metric("Total Orders", len(sub_df))
    c2.metric("Total Spend", f"LKR {sub_df['TotSum (actual)'].sum():,.2f}" if 'TotSum (actual)' in sub_df.columns else "LKR 0.00")
    st.markdown("#### üìÖ Activity Timeline")
    if 'TotSum (actual)' in sub_df.columns and not sub_df.empty:
        sub_df = sub_df.copy()
        sub_df['neg_flag'] = sub_df['TotSum (actual)'].apply(lambda x: 'Negative' if x < 0 else 'Positive')
        sub_df['plot_size'] = sub_df['TotSum (actual)'].abs() + 1
        color_map = {'Negative': 'red', 'Positive': '#636efa'}
        fig = px.scatter(sub_df, x='Created_Date', y='TotSum (actual)', color='neg_flag', size='plot_size',
                         color_discrete_map=color_map, hover_data=['Description', 'Order', 'Order Type'])
    else:
        fig = px.scatter(sub_df, x='Created_Date', y='TotSum (actual)' if 'TotSum (actual)' in sub_df.columns else None, hover_data=['Description'])
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("#### üìã Work Log")
    show_cols = [c for c in ['Created_Date', 'Order', 'Description', 'Equipment description', 'TotSum (actual)'] if c in sub_df.columns]
    st.dataframe(sub_df[show_cols], use_container_width=True)

@st.dialog("üìÖ Daily Report", width="large")
def show_day_details(day_val, df):
    st.markdown(f"### Report for: **{day_val}**")
    sub_df = df[df['Day_Num'] == day_val]
    c1, c2, c3 = st.columns(3)
    c1.metric("Jobs Created", len(sub_df))
    c2.metric("Total Cost", f"LKR {sub_df['TotSum (actual)'].sum():,.2f}" if 'TotSum (actual)' in sub_df.columns else "LKR 0.00")
    c3.metric("Depts Involved", len(sub_df['Main WorkCtr'].unique()) if 'Main WorkCtr' in sub_df.columns else 0)
    st.divider()
    cols = [c for c in ['Order', 'Description', 'Equipment description', 'Main WorkCtr', 'TotSum (actual)'] if c in sub_df.columns]
    st.dataframe(sub_df[cols], use_container_width=True)

# --- HELPER FUNCTIONS FOR ANALYZER ---
def monthly_series(series_df, date_col='Created_Date', value_col='TotSum (actual)'):
    series_df = series_df.copy()
    series_df[date_col] = pd.to_datetime(series_df[date_col], errors='coerce')
    series_df = series_df.dropna(subset=[date_col])
    if series_df.empty:
        return pd.Series(dtype=float)
    series_df['Month'] = series_df[date_col].dt.to_period('M')
    ms = series_df.groupby('Month')[value_col].sum().sort_index()
    return ms

def predict_linear_monthly(ms, months_ahead=3, min_months=3):
    """
    Predict next months using linear regression.
    Require at least min_months months of history to produce forecasts.
    If insufficient data, returns None.
    """
    if months_ahead <= 0:
        return []
    if ms is None or len(ms) == 0:
        return None
    if len(ms) < min_months:
        return None
    if len(ms) == 1:
        return [float(ms.iloc[0])] * months_ahead
    x = np.arange(len(ms)).reshape(-1, 1)
    y = ms.values
    model = LinearRegression().fit(x, y)
    preds = []
    start = len(ms)
    for i in range(months_ahead):
        preds.append(float(model.predict(np.array([[start + i]]))))
    return preds

def _plot_history_and_forecast(ms: pd.Series, preds, title: str, y_label: str = "Value"):
    """
    ms: pd.Series indexed by Period('M'), numeric values (historical monthly sums)
    preds: list of forecast numbers (length months_ahead) or None
    This function plots historical monthly points (month-end) and a daily-resolution forecast line (red dotted)
    that interpolates between the last historical month-end and the forecast month-end points.
    """
    fig = go.Figure()
    # Historical
    if ms is not None and len(ms) > 0:
        x_hist = [p.to_timestamp(how='end') for p in ms.index]
        y_hist = ms.values
        fig.add_trace(go.Scatter(x=x_hist, y=y_hist, mode='lines+markers', name='Historical', line=dict(color='#1f77b4', width=3)))
    else:
        x_hist = []
        y_hist = np.array([])

    # Forecast
    if preds is not None and len(preds) > 0:
        # build forecast period-ends
        if len(x_hist) > 0:
            last_period = ms.index.max()
            forecast_periods = [last_period + (i+1) for i in range(len(preds))]
            forecast_ts = [p.to_timestamp(how='end') for p in forecast_periods]
            # numeric points for interpolation
            x_points = np.array([dt.timestamp() for dt in (x_hist + forecast_ts)])
            y_points = np.concatenate([y_hist, np.array(preds)])
            # create daily timeline from last historical day+1 to final forecast end
            start_date = x_hist[-1] + pd.Timedelta(days=1)
            end_date = forecast_ts[-1]
            if start_date <= end_date:
                x_daily = pd.date_range(start=start_date, end=end_date, freq='D').to_pydatetime().tolist()
                x_daily_num = np.array([d.timestamp() for d in x_daily])
                # interpolation (linear)
                y_daily = np.interp(x_daily_num, x_points, y_points)
                # plot forecast dotted red line (daily)
                fig.add_trace(go.Scatter(x=x_daily, y=y_daily, mode='lines', name='Forecast (daily)', line=dict(color='red', dash='dot')))
            # also add markers at forecast month-ends
            fig.add_trace(go.Scatter(x=forecast_ts, y=preds, mode='markers+lines', name='Forecast (month-end)', line=dict(color='red', dash='dot'), marker=dict(symbol='circle', size=8, color='red')))
        else:
            # No historical data: create forecast points anchored at month-ends from today
            today = pd.Timestamp(datetime.now().date())
            forecast_ts = [(today + relativedelta(months=i+1)).to_pydatetime() for i in range(len(preds))]
            # daily series from tomorrow to final forecast end
            start_date = today + pd.Timedelta(days=1)
            end_date = forecast_ts[-1]
            x_daily = pd.date_range(start=start_date, end=end_date, freq='D').to_pydatetime().tolist()
            # linear interpolation between 0 and forecast month-end values (simple ramp)
            x_points = np.array([start_date.timestamp()] + [dt.timestamp() for dt in forecast_ts])
            y_points = np.concatenate([[0.0], np.array(preds)])
            x_daily_num = np.array([d.timestamp() for d in x_daily])
            if len(x_daily_num) > 0:
                y_daily = np.interp(x_daily_num, x_points, y_points)
                fig.add_trace(go.Scatter(x=x_daily, y=y_daily, mode='lines', name='Forecast (daily)', line=dict(color='red', dash='dot')))
            fig.add_trace(go.Scatter(x=forecast_ts, y=preds, mode='markers+lines', name='Forecast (month-end)', line=dict(color='red', dash='dot'), marker=dict(symbol='circle', size=8, color='red')))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title=y_label, template='plotly_white', hovermode='x unified')
    return fig

# --- DEEP 6-MONTH AI ANALYZER (NEW MODE) ---
def deep_six_month_analyzer(df):
    st.markdown('<div class="ai-banner">AI Analyzer ‚Äî Deep Six-Month Forecast (Adjustable Horizon)</div>', unsafe_allow_html=True)
    with st.expander("‚ÑπÔ∏è About this AI Analyzer"):
        st.write("- Uses the last 6 months of data only (by Created_Date).")
        st.write("- Forecast horizon is configurable (Next 1 month, Next 2 months, Next 3 months). Minimum 3 monthly historical points are required for linear forecasting where noted.")
        st.write("- All charts are interactive; select items from tables to view detailed drilldowns.")

    if 'Created_Date' not in df.columns:
        st.error("Created_Date column required. Ensure files contain 'Created On' so Created_Date exists after load.")
        return

    # Forecast horizon selector (New UI element)
    horizon_map = {"Next 1 month": 1, "Next 2 months": 2, "Next 3 months (Quarter)": 3}
    horizon_choice = st.selectbox("Forecast horizon:", list(horizon_map.keys()), index=2)
    months_ahead = horizon_map[horizon_choice]

    df = df.copy()
    df['Created_Date'] = pd.to_datetime(df['Created_Date'], errors='coerce')
    df = df.dropna(subset=['Created_Date'])
    if df.empty:
        st.warning("No valid Created_Date entries found.")
        return

    max_date = df['Created_Date'].max()
    cutoff = (max_date - relativedelta(months=6)).replace(day=1)
    df6 = df[df['Created_Date'] >= cutoff].copy()
    if df6.empty:
        st.warning("No data in the last 6 months range.")
        return

    text_col = 'Description' if 'Description' in df6.columns else None
    descriptions = df6[text_col].astype(str).fillna('') if text_col else pd.Series([], dtype=str)

    # Tokenization/keyword cost weighting (fixed sparse multiply bug)
    token_df = pd.DataFrame(columns=['token', 'total_cost', 'count'])
    if text_col and not descriptions.empty:
        try:
            vectorizer = CountVectorizer(stop_words='english', token_pattern=r'(?u)\b[a-zA-Z]{3,}\b')
            X = vectorizer.fit_transform(descriptions)            # shape: (n_rows, n_tokens)
            tokens = vectorizer.get_feature_names_out()
            costs = df6['TotSum (actual)'].fillna(0).values       # shape: (n_rows,)
            # compute total cost per token using X.T.dot(costs)
            token_costs = np.asarray(X.T.dot(costs)).ravel()      # shape: (n_tokens,)
            token_counts = np.asarray(X.sum(axis=0)).ravel()      # shape: (n_tokens,)
            token_df = pd.DataFrame({'token': tokens, 'total_cost': token_costs, 'count': token_counts}).sort_values('total_cost', ascending=False)
        except Exception as e:
            st.info("Tokenization or token-cost weighting failed: " + str(e))
            token_df = pd.DataFrame(columns=['token', 'total_cost', 'count'])

    st.markdown("#### 1. Financial & Budget Forecasting")

    # 1.1 Monthly Breakdown Cost Forecast (ZLT2)
    zlt2_df = df6[df6.get('Order Type', '') == 'Breakdown maintenance'] if 'Order Type' in df6.columns else df6.iloc[0:0]
    zlt2_monthly = monthly_series(zlt2_df, value_col='TotSum (actual)') if not zlt2_df.empty else pd.Series(dtype=float)
    zlt2_preds = predict_linear_monthly(zlt2_monthly, months_ahead=months_ahead, min_months=3)
    st.markdown("**1.1 Monthly Breakdown Cost Forecast**")
    if zlt2_preds is None:
        st.warning("Not enough monthly ZLT2 history (minimum 3 monthly points required) to produce a reliable forecast. Showing historical totals where available.")
        if not zlt2_monthly.empty:
            fig = _plot_history_and_forecast(zlt2_monthly, None, "ZLT2 Historical Monthly Costs", "LKR")
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.write("No ZLT2 data available.")
    else:
        out1_1 = pd.DataFrame({
            'Month': [(max_date + relativedelta(months=i+1)).strftime('%Y-%m') for i in range(months_ahead)],
            'Predicted_Breakdown_Cost_LKR': [max(0.0, p) for p in zlt2_preds]
        })
        st.dataframe(out1_1.style.format({"Predicted_Breakdown_Cost_LKR": "LKR {:,.2f}"}), use_container_width=True)
        fig = _plot_history_and_forecast(zlt2_monthly, zlt2_preds, "ZLT2 Historical & Forecasted Monthly Costs", "LKR")
        st.plotly_chart(fig, use_container_width=True)

    # 1.2 Annual Budget Deviation Forecast (line chart with projection)
    st.markdown("**1.2 Annual Budget Deviation Forecast**")
    df6['Cost_Variance'] = df6.get('Cost_Variance', df6.get('TotSum (actual)', 0) - df6.get('TotSum (plan)', 0))
    var_monthly = df6.groupby(df6['Created_Date'].dt.to_period('M'))['Cost_Variance'].sum().sort_index()
    last_month = max_date.month
    months_remaining = 12 - last_month
    projected_remaining = 0.0
    var_preds = None
    if months_remaining > 0 and len(var_monthly) >= 3:
        var_preds = predict_linear_monthly(var_monthly, months_ahead=months_remaining, min_months=3)
        if var_preds is not None:
            projected_remaining = sum(var_preds)
    elif months_remaining > 0 and len(var_monthly) > 0:
        projected_remaining = var_monthly.mean() * months_remaining
    current_year_variance = var_monthly.sum()
    annual_overrun_forecast = current_year_variance + projected_remaining
    st.markdown(f"- Forecasted maintenance cost overrun (Actual vs Plan) for current year: LKR {annual_overrun_forecast:,.2f}")

    # plot monthly variance with projection to year end
    fig_var = _plot_history_and_forecast(var_monthly, var_preds, "Monthly Cost Variance (Actual - Plan) and Projection to Year End", "LKR")
    st.plotly_chart(fig_var, use_container_width=True)

    # Provide drilldown: select month to view raw rows
    if not var_monthly.empty:
        with st.expander("üîé Explore monthly variance details"):
            month_options = [m.strftime('%Y-%m') for m in var_monthly.index.to_timestamp()]
            sel_month = st.selectbox("Select month", month_options)
            sel_period = pd.Period(sel_month, freq='M')
            rows = df6[df6['Created_Date'].dt.to_period('M') == sel_period]
            st.dataframe(rows.sort_values('Created_Date', ascending=False), use_container_width=True)
            if 'Equipment description' in rows.columns:
                sel_eq = st.selectbox("Select equipment from this month to view details", sorted(rows['Equipment description'].dropna().unique().tolist()))
                if sel_eq:
                    if st.button("View Equipment History (selected)"):
                        show_machine_details(sel_eq, df6)

    # 1.3 Departmental Spending Forecast (with line charts)
    st.markdown("**1.3 Departmental Spending Forecast (Mechanical vs Electrical)**")
    mech = df6[df6.get('Main WorkCtr', '') == 'Mechanical Dpt.'] if 'Main WorkCtr' in df6.columns else df6.iloc[0:0]
    elec = df6[df6.get('Main WorkCtr', '') == 'Electrical Dpt.'] if 'Main WorkCtr' in df6.columns else df6.iloc[0:0]
    mech_monthly = monthly_series(mech) if not mech.empty else pd.Series(dtype=float)
    elec_monthly = monthly_series(elec) if not elec.empty else pd.Series(dtype=float)
    mech_preds = predict_linear_monthly(mech_monthly, months_ahead=months_ahead, min_months=3)
    elec_preds = predict_linear_monthly(elec_monthly, months_ahead=months_ahead, min_months=3)
    if mech_preds is None or elec_preds is None:
        st.warning("Not enough departmental monthly history (minimum 3 months) to produce reliable dept forecasts; using simple averages where necessary.")
    mech_total = sum(max(0, p) for p in mech_preds) if mech_preds is not None else (mech_monthly.mean() * months_ahead if not mech_monthly.empty else 0.0)
    elec_total = sum(max(0, p) for p in elec_preds) if elec_preds is not None else (elec_monthly.mean() * months_ahead if not elec_monthly.empty else 0.0)
    st.markdown(f"- Mechanical forecast for selected horizon: LKR {mech_total:,.2f}")
    st.markdown(f"- Electrical forecast for selected horizon: LKR {elec_total:,.2f}")
    winner = "Mechanical Dpt." if mech_total > elec_total else "Electrical Dpt." if elec_total > mech_total else "Tie"
    st.markdown(f"**Projected higher increase:** {winner}")

    # Plot departmental historical + forecast lines
    fig_mech = _plot_history_and_forecast(mech_monthly, mech_preds, "Mechanical Dept: Historical & Forecasted Spend", "LKR")
    fig_elec = _plot_history_and_forecast(elec_monthly, elec_preds, "Electrical Dept: Historical & Forecasted Spend", "LKR")
    st.plotly_chart(fig_mech, use_container_width=True)
    st.plotly_chart(fig_elec, use_container_width=True)

    # 1.4 Major Spare Parts Cost Prediction (bar chart + select for details)
    st.markdown("**1.4 Major Spare Parts Cost Prediction (Top tokens)**")
    likely_spare_tokens = [k for k in ['bearing','seal','motor','valve','gear','pump','shaft','coupling','belt','sensor'] if k in token_df['token'].tolist()]
    top_spares = token_df[token_df['token'].isin(likely_spare_tokens)].head(5)
    if top_spares.empty and not token_df.empty:
        top_spares = token_df.head(5)
    spare_forecasts = []
    for tok in top_spares['token'].tolist():
        mask = df6[text_col].str.contains(r'\b' + re.escape(tok) + r'\b', case=False, na=False) if text_col else pd.Series(False, index=df6.index)
        tok_monthly = monthly_series(df6[mask], value_col='TotSum (actual)') if mask.any() else pd.Series(dtype=float)
        preds = predict_linear_monthly(tok_monthly, months_ahead=months_ahead, min_months=3)
        if preds is None:
            next_q_spend = tok_monthly.mean() * months_ahead if not tok_monthly.empty else 0.0
        else:
            next_q_spend = sum(max(0, p) for p in preds)
        spare_forecasts.append({'keyword': tok, 'next_period_spend': next_q_spend, 'historical_total': tok_monthly.sum() if not tok_monthly.empty else 0.0})
    spare_df = pd.DataFrame(spare_forecasts).sort_values('next_period_spend', ascending=False)
    if not spare_df.empty:
        st.dataframe(spare_df.style.format({"next_period_spend": "LKR {:,.2f}", "historical_total": "LKR {:,.2f}"}), use_container_width=True)
        st.plotly_chart(px.bar(spare_df, x='keyword', y='next_period_spend', title="Forecasted Spend on Top Spare Keywords", labels={'next_period_spend':'LKR'}), use_container_width=True)
        sel_spare = st.selectbox("Select spare keyword to view related records", spare_df['keyword'].tolist())
        if sel_spare:
            related_rows = df6[df6['Description'].astype(str).str.contains(r'\b' + re.escape(sel_spare) + r'\b', case=False, na=False)]
            st.markdown(f"Related records count: {len(related_rows)}")
            st.dataframe(related_rows[['Created_Date','Order','Description','Equipment description','TotSum (actual)']].sort_values('Created_Date', ascending=False), use_container_width=True)
            if 'Equipment description' in related_rows.columns:
                equipment_options = sorted(related_rows['Equipment description'].dropna().unique().tolist())
                if equipment_options:
                    sel_eq = st.selectbox("Select equipment (from related rows) to view full history", equipment_options, key=f"spare_eq_{sel_spare}")
                    if sel_eq and st.button("View Equipment History (spare selection)"):
                        show_machine_details(sel_eq, df6)
    else:
        st.write("No spare-part related tokens detected in Description.")

    # 1.5 Cost per Asset Trend (bar + clickable)
    st.markdown("**1.5 Cost per Asset Trend (Top 10 machines)**")
    if 'Equipment description' in df6.columns:
        asset_costs = df6.groupby('Equipment description')['TotSum (actual)'].sum().sort_values(ascending=False)
        top10 = asset_costs.head(10).index.tolist()
        asset_forecasts = []
        for a in top10:
            a_df = df6[df6['Equipment description'] == a]
            a_monthly = monthly_series(a_df)
            preds = predict_linear_monthly(a_monthly, months_ahead=months_ahead, min_months=3)
            if preds is None:
                est = a_monthly.mean() * months_ahead if not a_monthly.empty else 0.0
            else:
                est = sum(max(0, p) for p in preds)
            asset_forecasts.append({'Machine': a, 'next_period_cost': est})
        af_df = pd.DataFrame(asset_forecasts).sort_values('next_period_cost', ascending=False)
        st.dataframe(af_df.style.format({"next_period_cost": "LKR {:,.2f}"}), use_container_width=True)
        st.plotly_chart(px.bar(af_df, x='Machine', y='next_period_cost', title=f"Top {len(af_df)} Machines: Forecasted Spend for Selected Horizon", labels={'next_period_cost':'LKR'}), use_container_width=True)
        sel_machine = st.selectbox("Select machine to view full history", af_df['Machine'].tolist())
        if sel_machine:
            if st.button("View Machine History (from asset forecast)"):
                show_machine_details(sel_machine, df6)
    else:
        st.write("No Equipment description column to evaluate assets.")

    st.markdown("#### 2. Equipment & Reliability Forecasting")

    # 2.1 MTBF Prediction for Top 3 (by ZLT2 count) with timeline chart
    st.markdown("**2.1 MTBF Prediction (Top 3 assets by ZLT2 count)**")
    if 'Order Type' in df6.columns and 'Equipment description' in df6.columns:
        zlt2_counts = df6[df6['Order Type'] == 'Breakdown maintenance'].groupby('Equipment description').size().sort_values(ascending=False)
        top3 = zlt2_counts.head(3).index.tolist()
        mtbf_results = []
        for mach in top3:
            sub = df6[(df6['Equipment description'] == mach) & (df6['Order Type'] == 'Breakdown maintenance')].sort_values('Created_Date')
            if len(sub) > 1:
                diffs = sub['Created_Date'].diff().dt.days.dropna()
                mean_days = diffs.mean()
                last_date = sub['Created_Date'].max()
                low = max(1, int(mean_days * 0.8))
                high = max(low, int(mean_days * 1.2))
                next_low = (last_date + pd.Timedelta(days=low)).date()
                next_high = (last_date + pd.Timedelta(days=high)).date()
                mtbf_results.append({'Machine': mach, 'mtbf_days': float(mean_days), 'next_failure_window': f"{next_low} to {next_high}"})
        if mtbf_results:
            st.dataframe(pd.DataFrame(mtbf_results), use_container_width=True)
            # timeline scatter of last events for top3
            timeline_df = df6[df6['Equipment description'].isin(top3) & (df6.get('Order Type','') == 'Breakdown maintenance')]
            if not timeline_df.empty:
                timeline_df = timeline_df.sort_values('Created_Date')
                fig_t = px.scatter(timeline_df, x='Created_Date', y='Equipment description', color='Equipment description', size='TotSum (actual)' if 'TotSum (actual)' in timeline_df.columns else None, title="Breakdown Events Timeline for Top 3 ZLT2 Assets", hover_data=['Description','Order'])
                st.plotly_chart(fig_t, use_container_width=True)
        else:
            st.write("Not enough breakdown history to compute MTBF for top assets.")
    else:
        st.write("Order Type or Equipment description columns missing for MTBF analysis.")

    # (2.2 Failure Mode Seasonality removed as requested)

    # 2.3 Expected Equipment Life Remaining
    st.markdown("**2.3 Expected Equipment Life Remaining (qualitative)**")
    if 'Equipment description' in df6.columns:
        recent_cost = df6.groupby('Equipment description')['TotSum (actual)'].sum()
        first_seen = df6.groupby('Equipment description')['Created_Date'].min()
        candidates = pd.DataFrame({'first_seen': first_seen, 'recent_cost': recent_cost}).sort_values('recent_cost', ascending=False)
        if not candidates.empty:
            a = candidates.index[0]
            a_monthly = monthly_series(df6[df6['Equipment description'] == a])
            slope = 0.0
            if len(a_monthly) >= 2:
                x = np.arange(len(a_monthly)).reshape(-1, 1)
                slope = LinearRegression().fit(x, a_monthly.values).coef_[0]
            if slope > 0 and (a_monthly.mean() != 0 and slope / (a_monthly.mean()) > 0.2):
                rul = "Less than 6 months RUL"
            elif slope > 0:
                rul = "6-12 months RUL"
            else:
                rul = "More than 12 months RUL"
            st.markdown(f"- Asset prioritized: **{a}**")
            st.markdown(f"- Estimated Remaining Useful Life (qualitative): **{rul}**")
            # show trend chart for this asset
            asset_ts = monthly_series(df6[df6['Equipment description'] == a])
            preds_asset = predict_linear_monthly(asset_ts, months_ahead=months_ahead, min_months=3)
            fig_asset_trend = _plot_history_and_forecast(asset_ts, preds_asset, f"Cost Trend for {a}", "LKR")
            st.plotly_chart(fig_asset_trend, use_container_width=True)
        else:
            st.write("Insufficient asset cost data for RUL estimation.")
    else:
        st.write("No Equipment description column.")

    # 2.4 PM Effectiveness Failure Forecast
    st.markdown("**2.4 PM Effectiveness Failure Forecast**")
    if 'Order Type' in df6.columns and 'Equipment description' in df6.columns:
        pm_df = df6[df6['Order Type'] == 'Preventive maintenance']
        breakdown_df = df6[df6['Order Type'] == 'Breakdown maintenance']
        pm_count = len(pm_df)
        if pm_count > 0:
            pm_followed_break = 0
            for idx, pm in pm_df.iterrows():
                eq = pm.get('Equipment description')
                pm_date = pm.get('Created_Date')
                window = breakdown_df[(breakdown_df['Equipment description'] == eq) & (breakdown_df['Created_Date'] > pm_date) & (breakdown_df['Created_Date'] <= pm_date + pd.Timedelta(days=30))]
                if not window.empty:
                    pm_followed_break += 1
            rate = pm_followed_break / pm_count
            avg_monthly_pms = pm_df.groupby(pm_df['Created_Date'].dt.to_period('M')).size().mean() if not pm_df.empty else 0
            expected_pms_next_period = (avg_monthly_pms * months_ahead) if not np.isnan(avg_monthly_pms) else 0
            expected_poor_pm_breakdowns = rate * expected_pms_next_period
            st.markdown(f"- Historical PMs: {pm_count}, PMs followed by breakdown within 30 days: {pm_followed_break}")
            st.markdown(f"- Forecasted breakdowns within 1 month after PM for selected horizon: {expected_poor_pm_breakdowns:.1f}")
            # Pie chart of PM outcomes if possible (fixed column naming)
            pm_outcomes = pd.Series(['Followed by Breakdown' if (breakdown_df[(breakdown_df['Equipment description'] == pm.get('Equipment description')) & (breakdown_df['Created_Date'] > pm.get('Created_Date')) & (breakdown_df['Created_Date'] <= pm.get('Created_Date') + pd.Timedelta(days=30))].shape[0] > 0) else 'No Breakdown' for _, pm in pm_df.iterrows()])
            if not pm_outcomes.empty:
                pm_counts = pm_outcomes.value_counts().reset_index()
                pm_counts.columns = ['Outcome', 'Count']
                st.plotly_chart(px.pie(pm_counts, names='Outcome', values='Count', title="PM Outcomes (last 6 months)"), use_container_width=True)
        else:
            st.write("No PM (ZLT4) records in the last 6 months to evaluate.")
    else:
        st.write("Order Type or Equipment description missing for PM effectiveness.")

    # 2.5 Lubrication Failure Prediction
    st.markdown("**2.5 Lubrication Failure Prediction**")
    bearing_mask = df6['Description'].astype(str).str.contains(r'\bbearing\b', case=False, na=False) if 'Description' in df6.columns else pd.Series(False, index=df6.index)
    trip_mask = df6['Description'].astype(str).str.contains(r'\btrip\b|\btripped\b', case=False, na=False) if 'Description' in df6.columns else pd.Series(False, index=df6.index)
    related_mask = bearing_mask | trip_mask
    related_count = int(related_mask.sum()) if hasattr(related_mask, 'sum') else 0
    overall_count = len(df6)
    related_prop = related_count / overall_count if overall_count > 0 else 0
    related_monthly = df6[related_mask].groupby(df6['Created_Date'].dt.to_period('M')).size() if related_count > 0 else pd.Series(dtype=float)
    if len(related_monthly) >= 2:
        recent = related_monthly.iloc[-1]
        prev = related_monthly.iloc[-2] if len(related_monthly) >= 2 else recent
        pct_change = ((recent - prev) / prev) * 100 if prev != 0 else 0.0
    else:
        pct_change = 0.0
    suggested_change_pct = max(-50, min(200, pct_change))
    st.markdown(f"- Bearing/Motor related events proportion (last 6 months): {related_prop:.2%}")
    st.markdown(f"- Month-over-month change (most recent): {pct_change:.1f}%")
    st.markdown(f"- Suggested change in lubricant purchases for next period: {suggested_change_pct:.1f}%")
    if not related_monthly.empty:
        fig_rel = _plot_history_and_forecast(related_monthly, predict_linear_monthly(related_monthly, months_ahead=months_ahead, min_months=3), "Bearing/Trip Related Events: Historical & Forecast", "Events")
        st.plotly_chart(fig_rel, use_container_width=True)

    st.markdown("#### 3. Workload & Resource Forecasting")

    # 3.1 Total Order Volume Forecast
    st.markdown("**3.1 Total Order Volume Forecast**")
    vol_monthly = df6.groupby(df6['Created_Date'].dt.to_period('M')).size().sort_index()
    vol_preds = predict_linear_monthly(vol_monthly, months_ahead=months_ahead, min_months=3)
    if vol_preds is None:
        st.warning("Not enough monthly volume history (minimum 3 months) to make a reliable forecast. Using average instead.")
        vol_pred_val = int(np.round(vol_monthly.mean())) if not vol_monthly.empty else len(df6)
        fig_vol = _plot_history_and_forecast(vol_monthly, None, "Order Volume (Historical)")
    else:
        vol_pred_val = int(np.round(sum(vol_preds))) if months_ahead > 1 else int(np.round(vol_preds[0]))
        fig_vol = _plot_history_and_forecast(vol_monthly, vol_preds, "Order Volume: Historical & Forecast", "Orders")
    st.markdown(f"- Predicted total number of work orders for selected horizon: **{vol_pred_val}**")
    st.plotly_chart(fig_vol, use_container_width=True)

    # 3.2 Craft/Skill Demand (Welding)
    st.markdown("**3.2 Craft/Skill Demand ‚Äî Welding hours (selected horizon)**")
    if text_col:
        welding_mask = df6['Description'].astype(str).str.contains(r'\bweld|welding\b', case=False, na=False)
        welding_monthly = welding_mask.groupby(df6['Created_Date'].dt.to_period('M')).sum()
        welding_preds = predict_linear_monthly(welding_monthly, months_ahead=months_ahead, min_months=3)
        if welding_preds is None:
            welding_pred_orders = int(np.round(welding_monthly.mean() * months_ahead)) if not welding_monthly.empty else 0
        else:
            welding_pred_orders = int(np.round(sum(welding_preds)))
        avg_hours_per_welding = 4
        welding_hours_next_period = welding_pred_orders * avg_hours_per_welding
        st.markdown(f"- Estimated welding maintenance hours needed for selected horizon: **{welding_hours_next_period:.0f} hours** (assumed {avg_hours_per_welding}h per welding order)")
        if not welding_monthly.empty:
            fig_weld = _plot_history_and_forecast(welding_monthly, welding_preds, "Welding Order Count: Historical & Forecast", "Orders")
            st.plotly_chart(fig_weld, use_container_width=True)
    else:
        st.write("No Description column to analyze craft-specific keywords.")

    # 3.3 Manpower Utilization Forecast
    st.markdown("**3.3 Manpower Utilization Forecast (selected horizon)**")
    tech_count = df6['Entered By'].nunique() if 'Entered By' in df6.columns and df6['Entered By'].nunique() > 0 else 10
    avg_hours_per_order = 3
    vol_preds_q = predict_linear_monthly(vol_monthly, months_ahead=months_ahead, min_months=3)
    if vol_preds_q is None:
        predicted_orders_q = int(round(vol_monthly.mean() * months_ahead)) if not vol_monthly.empty else len(df6)
    else:
        predicted_orders_q = int(round(sum(vol_preds_q)))
    required_hours_q = predicted_orders_q * avg_hours_per_order
    available_hours_q = tech_count * 8 * 22 * months_ahead
    utilization_pct = min(100.0, (required_hours_q / available_hours_q) * 100) if available_hours_q > 0 else 0.0
    st.markdown(f"- Estimated technician count: {tech_count}")
    st.markdown(f"- Forecasted manpower utilization for selected horizon: **{utilization_pct:.1f}%** (based on {avg_hours_per_order}h/order)")

    # 3.4 Daily Order Creation Volatility
    st.markdown("**3.4 Daily Order Creation Volatility ‚Äî Peak Day**")
    if 'Created_Date' in df6.columns:
        day_counts = df6.groupby(df6['Created_Date'].dt.day_name()).size().sort_values(ascending=False)
        peak_day = day_counts.idxmax() if not day_counts.empty else "N/A"
        peak_count = int(day_counts.max()) if not day_counts.empty else 0
        st.markdown(f"- Peak day of the week (persistent): **{peak_day}** with average {peak_count} orders on peak days.")
        if not day_counts.empty:
            day_df = day_counts.reset_index()
            day_df.columns = ['Day', 'Count']
            st.plotly_chart(px.bar(day_df, x='Day', y='Count', title="Orders by Day of Week"), use_container_width=True)
    else:
        st.write("No Created_Date column to compute daily volatility.")

    # 3.5 Backlog Duration Forecast
    st.markdown("**3.5 Backlog Duration Forecast**")
    if 'User Status Text' in df6.columns and 'Created_Date' in df6.columns and 'Order' in df6.columns:
        awaiting = df6[df6['User Status Text'].astype(str).str.contains('Awaiting', case=False, na=False)]
        closed = df6[df6['User Status Text'].astype(str).str.contains('Closed', case=False, na=False)]
        if not awaiting.empty and not closed.empty:
            merged = pd.merge(awaiting[['Order','Created_Date']], closed[['Order','Created_Date']], on='Order', suffixes=('_await','_closed'))
            merged = merged[merged['Created_Date_closed'] >= merged['Created_Date_await']]
            merged['delta_days'] = (merged['Created_Date_closed'] - merged['Created_Date_await']).dt.days
            avg_delta = merged['delta_days'].mean() if not merged.empty else np.nan
            if not np.isnan(avg_delta):
                st.markdown(f"- Forecast average time for non-critical order to move from 'Awaiting Approval' to 'Closed': **{avg_delta:.1f} days**")
                st.plotly_chart(px.histogram(merged, x='delta_days', nbins=20, title="Awaiting -> Closed: Distribution of Days"), use_container_width=True)
            else:
                st.write("- Insufficient data to calculate backlog duration for non-critical orders.")
        else:
            st.write("Insufficient awaiting/closed transition data to compute backlog duration.")
    else:
        st.write("User Status Text, Created_Date or Order missing for backlog duration analysis.")

    st.markdown("#### 4. Data & Process Improvement Forecasting")

    # 4.1 Missing Data Rate Forecast
    st.markdown("**4.1 Missing Data Rate Forecast (Equipment or Functional Loc.)**")
    miss_equipment_rate = df6['Equipment'].isnull().mean() if 'Equipment' in df6.columns else 0.0
    miss_funcloc_rate = df6['Functional Loc.'].isnull().mean() if 'Functional Loc.' in df6.columns else 0.0
    st.markdown(f"- Predicted missing Equipment rate next period: **{miss_equipment_rate:.1%}**")
    st.markdown(f"- Predicted missing Functional Loc. rate next period: **{miss_funcloc_rate:.1%}**")
    # bar chart
    miss_df = pd.DataFrame({
        'Field': ['Equipment', 'Functional Loc.'],
        'MissingRate': [miss_equipment_rate, miss_funcloc_rate]
    })
    st.plotly_chart(px.bar(miss_df, x='Field', y='MissingRate', title="Missing Data Rates (last 6 months)", labels={'MissingRate':'Missing Rate'}), use_container_width=True)

    # 4.2 PM Compliance Rate Forecast
    st.markdown("**4.2 PM Compliance Rate Forecast (on-time completion of ZLT4)**")
    if 'Order Type' in df6.columns and 'Response_Time' in df6.columns:
        pm = df6[df6['Order Type'] == 'Preventive maintenance']
        if not pm.empty:
            on_time_rate = (pm['Response_Time'] <= 7).mean()
            pm_monthly_on_time = pm.groupby(pm['Created_Date'].dt.to_period('M')).apply(lambda x: (x['Response_Time']<=7).mean())
            projected_rate = on_time_rate
            if len(pm_monthly_on_time) >= 3:
                slope = np.polyfit(np.arange(len(pm_monthly_on_time)), pm_monthly_on_time.values, 1)[0]
                projected_rate = max(0, min(1, pm_monthly_on_time.iloc[-1] + slope * months_ahead))
            st.markdown(f"- Forecast PM on-time completion for selected horizon: **{projected_rate:.1%}**")
            if not pm_monthly_on_time.empty:
                fig_pm = _plot_history_and_forecast(pm_monthly_on_time, None, "PM On-time Rate (Historical)", "On-time Rate")
                st.plotly_chart(fig_pm, use_container_width=True)
        else:
            st.write("No PM (ZLT4) records in the last 6 months.")
    else:
        st.write("Order Type or Response_Time missing for PM compliance calculation.")

    # 4.3 Time-to-Approve Forecast (hours)
    st.markdown("**4.3 Time-to-Approve Forecast (average hours to move out of 'Awaiting Approval')**")
    if 'User Status Text' in df6.columns and 'Created_Date' in df6.columns:
        awaiting_mask = df6['User Status Text'].astype(str).str.contains('Awaiting', case=False, na=False)
        awaiting_df = df6[awaiting_mask]
        if not awaiting_df.empty and 'Response_Time' in awaiting_df.columns:
            avg_days = awaiting_df['Response_Time'].mean()
            avg_hours = avg_days * 24
            st.markdown(f"- Expected time-to-approve next period (avg): **{avg_hours:.1f} hours**")
        else:
            st.write("Insufficient 'Awaiting' records with Response_Time to estimate time-to-approve.")
    else:
        st.write("User Status Text or Created_Date missing.")

    # 4.4 Top Generic Description Persistence
    st.markdown("**4.4 Top Generic Description Persistence**")
    if 'Description' in df6.columns:
        desc_counts = df6['Description'].astype(str).value_counts()
        top3_generic = desc_counts.head(3).index.tolist()
        total_desc = desc_counts.sum()
        persistence = []
        for d in top3_generic:
            share = desc_counts[d] / total_desc if total_desc > 0 else 0
            prob = min(100, share * 120)
            persistence.append({'Description': d, 'Current_Share_pct': share * 100, 'Persistence_pct_next_period': prob})
        pers_df = pd.DataFrame(persistence)
        st.dataframe(pers_df.style.format({"Current_Share_pct":"{:.1f}%","Persistence_pct_next_period":"{:.1f}%"}), use_container_width=True)
        sel_desc = st.selectbox("Select a top generic description to see records", top3_generic)
        if sel_desc:
            recs = df6[df6['Description'] == sel_desc]
            st.dataframe(recs[['Created_Date','Order','Equipment description','TotSum (actual)']].sort_values('Created_Date', ascending=False), use_container_width=True)
    else:
        st.write("No Description column available.")

    # 4.5 RCA Priority Forecast
    st.markdown("**4.5 Root Cause Analysis (RCA) Priority Forecast**")
    if 'Description' in df6.columns:
        if 'Order' in df6.columns:
            rc = df6.groupby('Description').agg(Count=('Order','count'), TotalCost=('TotSum (actual)','sum')).reset_index()
        else:
            rc = df6.groupby('Description').agg(Count=('Description','count'), TotalCost=('TotSum (actual)','sum')).reset_index()
        if not rc.empty:
            rc['score'] = rc['Count'] * (rc['TotalCost'].abs() + 1)
            rca_priority = rc.sort_values('score', ascending=False).iloc[0]
            st.markdown(f"- Priority RCA target for next period: **{rca_priority['Description']}**")
            st.markdown(f"  - Occurrences: {int(rca_priority['Count'])}, Total Cost: LKR {rca_priority['TotalCost']:,.2f}")
            st.dataframe(rc.sort_values('score', ascending=False).head(10), use_container_width=True)
            sel_rc = st.selectbox("Select event/description to view related records", rc['Description'].head(10).tolist())
            if sel_rc:
                rel = df6[df6['Description'] == sel_rc]
                st.dataframe(rel[['Created_Date','Order','Equipment description','TotSum (actual)']].sort_values('Created_Date', ascending=False), use_container_width=True)
        else:
            st.write("No descriptive events found to prioritize.")
    else:
        st.write("Description column not present for RCA identification.")

    # Optional LLM summary (safe/optional)
    try:
        with st.expander("üß† AI Summary (optional)"):
            prompt_summary = ("You are a reliability engineer. Provide a concise 5-bullet executive summary "
                              "highlighting critical forecasts and recommended immediate actions from the analysis.")
            llm = ChatOpenAI(temperature=0.0, model="gpt-4", openai_api_key=OPENAI_API_KEY)
            summary = llm(prompt_summary)
            st.markdown(summary.content if hasattr(summary, 'content') else str(summary))
    except Exception:
        pass

# --- COST POPUP ---
@st.dialog("üí∞ Detailed Cost & Budget Analysis", width="large")
def show_cost_popup(df):
    st.markdown("### üìä Financial Breakdown")
    c1, c2, c3 = st.columns([2, 2, 2])
    depts = ['All'] + sorted(df['Main WorkCtr'].astype(str).unique().tolist()) if 'Main WorkCtr' in df.columns else ['All']
    types = ['All'] + sorted([x for x in df['Order Type'].unique() if str(x) != 'nan']) if 'Order Type' in df.columns else ['All']
    sel_d = c1.selectbox("Department:", depts, key='pop_d')
    sel_t = c2.selectbox("Order Type:", types, key='pop_t')
    show_all = c3.checkbox("Show All Rows", value=True)
    dff = df.copy()
    if sel_d != 'All':
        dff = dff[dff['Main WorkCtr'] == sel_d]
    if sel_t != 'All':
        dff = dff[dff['Order Type'] == sel_t]
    st.markdown("#### üö® Top 10 Budget Overruns")
    over = dff[dff.get('Cost_Variance', 0) > 0].nlargest(10, 'Cost_Variance') if 'Cost_Variance' in dff.columns else pd.DataFrame()
    show_cols = [c for c in ['Order', 'Description', 'TotSum (plan)', 'TotSum (actual)', 'Cost_Variance'] if c in over.columns]
    if not over.empty:
        st.dataframe(over[show_cols].style.format({"TotSum (plan)": "LKR {:,.2f}", "TotSum (actual)": "LKR {:,.2f}", "Cost_Variance": "LKR {:,.2f}"}), use_container_width=True)
        if 'Order' in over.columns:
            sel_over_order = st.selectbox("Select an overrun Order to view details", over['Order'].astype(str).tolist())
            if sel_over_order:
                rows = dff[dff['Order'].astype(str) == sel_over_order]
                st.dataframe(rows.T, use_container_width=True)
    else:
        st.write("No overruns found.")
    st.markdown("#### üí∏ Top 20 Costliest Machines")
    if 'Equipment description' in dff.columns:
        cost_df = dff[dff['Equipment description'] != "Unknown Asset"].groupby('Equipment description')['TotSum (actual)'].sum().reset_index().sort_values('TotSum (actual)', ascending=False)
        cost_df.columns = ['Machine Name', 'Total Cost (LKR)']
        st.dataframe((cost_df if show_all else cost_df.head(20)).style.format({"Total Cost (LKR)": "LKR {:,.2f}"}), use_container_width=True, height=400)
        sel_machine = st.selectbox("Select machine to view history", cost_df['Machine Name'].head(20).tolist())
        if sel_machine and st.button("View Machine History (from costs)"):
            show_machine_details(sel_machine, df)

# --- MAIN APP ---
def main():
    if 'removed_negatives' not in st.session_state:
        st.session_state['removed_negatives'] = None
    if 'negatives_restored' not in st.session_state:
        st.session_state['negatives_restored'] = False
    if 'show_filtered_negatives' not in st.session_state:
        st.session_state['show_filtered_negatives'] = False

    with st.sidebar:
        st.markdown('<div class="watermark">Created By Trainee at Engineering Dpt.</div>', unsafe_allow_html=True)
        st.markdown("""
            <div class="logo-container">
                <img src="https://cdn-icons-png.flaticon.com/512/2920/2920349.png" width="80">
                <h3>Maintenance Analyzer</h3>
            </div>
        """, unsafe_allow_html=True)

        mode = st.radio("Select Mode", ["Standard Dashboard", "AI Analyzer (Deep 6-Month Forecast)"])

        files_to_process = []
        if mode == "Standard Dashboard":
            uploaded = st.file_uploader("Upload Monthly File", type=['xlsx', 'csv'], accept_multiple_files=True)
            if uploaded:
                files_to_process = uploaded
        else:
            st.markdown("### Upload files covering the last 6 months (multiple files allowed)")
            uploaded_ai = st.file_uploader("Upload files (last 6 months)", type=['xlsx', 'csv'], accept_multiple_files=True, key="ai_uploads")
            if uploaded_ai:
                files_to_process = uploaded_ai

        st.markdown("---")

        if 'df_main' in st.session_state:
            st.markdown("### üîé Universal Search")
            search_q = st.text_input("Order # or Keyword", placeholder="Type here...")
            if search_q:
                mask = st.session_state['df_main'].astype(str).apply(lambda x: x.str.contains(search_q, case=False, na=False)).any(axis=1)
                search_results = st.session_state['df_main'][mask]
                st.write(f"Found {len(search_results)} matches:")
                show_cols = [c for c in ['Order', 'Description', 'TotSum (actual)'] if c in search_results.columns]
                st.dataframe(search_results[show_cols], hide_index=True)

        st.markdown("---")

        if 'df_main' in st.session_state and mode == "Standard Dashboard":
            if st.button("üì• Download Report (PDF)"):
                try:
                    pdf_path = generate_pdf(st.session_state['df_main'])
                    with open(pdf_path, "rb") as f:
                        st.download_button("Click to Save PDF", f, file_name="Maintenance_Report.pdf")
                except Exception as e:
                    st.error(f"PDF Error: {e}")

        st.markdown("---")
        if st.session_state.get('removed_negatives') is not None and not (st.session_state['removed_negatives'] is None) and not st.session_state['removed_negatives'].empty:
            if st.button("‚ûï Add Filtered Negative Rows to Dataset (Permanent)"):
                if 'df_main' in st.session_state and st.session_state['df_main'] is not None:
                    merged = pd.concat([st.session_state['df_main'], st.session_state['removed_negatives']], ignore_index=True)
                    st.session_state['df_main'] = merged
                    st.session_state['removed_negatives'] = pd.DataFrame()
                    st.session_state['negatives_restored'] = True
                    st.success("Filtered negative rows have been permanently added to the main dataset.")
                else:
                    st.error("No main dataset found to merge into. Please upload files first.")

    # HEADER & CLOCK & LOGO
    c_left, c_right = st.columns([5, 2])
    with c_left:
        st.markdown("""
            <div style="border-left: 6px solid #e11d48; padding-left: 15px; margin-top: 10px;">
                <h1 style='font-family: "Segoe UI", sans-serif; font-weight: 800; font-size: 2.5rem; color: #0f172a; margin: 0; line-height: 1.1; letter-spacing: -1px;'>
                    MAINTENANCE <span style='color: #e11d48;'>ANALYZER</span>
                </h1>
                <h3 style='font-family: "Segoe UI", sans-serif; font-weight: 500; font-size: 1.1rem; color: #64748b; margin-top: 5px; text-transform: uppercase; letter-spacing: 2px;'>
                    Lankatiles PLC
                </h3>
            </div>
        """, unsafe_allow_html=True)
    with c_right:
        if os.path.exists("lankatiles.png"):
            st.image("lankatiles.png", use_container_width=True)
        else:
            st.image("https://upload.wikimedia.org/wikipedia/commons/2/25/Lanka_Tiles_Logo.jpg", use_container_width=True)
        clock_html = """
        <!DOCTYPE html>
        <html>
        <head>
        <style>
            body { margin: 0; background: transparent; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 10px; height: 60px; font-family: Arial, Helvetica, sans-serif; }
            .clock-time { font-size: 1.3em; font-weight: bold; color: #333; line-height: 1.2; }
            .clock-date { font-size: 0.85em; color: #666; }
            @media (prefers-color-scheme: dark) { .clock-time { color: #eee; } .clock-date { color: #bbb; } }
        </style>
        </head>
        <body>
            <div id="live-time" class="clock-time">--:--:--</div>
            <div id="live-date" class="clock-date">...</div>
            <script>
                function updateClock() {
                    var now = new Date();
                    document.getElementById('live-time').innerHTML = now.toLocaleTimeString();
                    document.getElementById('live-date').innerHTML = now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                }
                setInterval(updateClock, 1000);
                updateClock();
            </script>
        </body>
        </html>
        """
        components.html(clock_html, height=80)

    if files_to_process:
        df_loaded, removed_neg = load_data(files_to_process)
        if df_loaded is not None:
            st.session_state['df_main'] = df_loaded
            if (st.session_state.get('removed_negatives') is None) or (st.session_state.get('negatives_restored') is False):
                st.session_state['removed_negatives'] = removed_neg
            st.session_state['negatives_restored'] = False

            df = df_loaded.copy()

            with st.sidebar:
                st.markdown("### üîç Filters")
                all_depts = ['All'] + sorted(df['Main WorkCtr'].astype(str).unique().tolist()) if 'Main WorkCtr' in df.columns else ['All']
                sel_dept = st.selectbox("Select Department", all_depts)
                all_types = ['All'] + sorted([x for x in df['Order Type'].unique() if str(x) != 'nan']) if 'Order Type' in df.columns else ['All']
                sel_type = st.selectbox("Select Order Type", all_types)

            if sel_dept != 'All':
                df = df[df['Main WorkCtr'] == sel_dept]
            if sel_type != 'All':
                df = df[df['Order Type'] == sel_type]

            if mode == "AI Analyzer (Deep 6-Month Forecast)":
                deep_six_month_analyzer(df)
            else:
                tabs = st.tabs(["ü§ñ AI Chat", "üí∞ Cost", "‚ö° Efficiency", "üîß Reliability", "üë∑ Workforce", "üßπ Quality"])

                # 1. AI CHAT
                with tabs[0]:
                    st.subheader("üí¨ Maintenance AI Assistant")
                    with st.expander("‚ÑπÔ∏è About this Section"):
                        st.write("Ask natural language questions about your data.")
                    st.write("‚ö° **Quick Actions:**")
                    col_q1, col_q2, col_q3 = st.columns(3)
                    prompt = None
                    if col_q1.button("üìâ Analyze Top Spenders"):
                        prompt = "List the top 5 most expensive machines and their total cost."
                    if col_q2.button("üîç Find Common Failures"):
                        prompt = "What are the most common descriptions for Breakdown maintenance?"
                    if col_q3.button("üìä Dept. Breakdown"):
                        prompt = "Give me a summary of total costs by Main Work Center."
                    if "messages" not in st.session_state:
                        st.session_state.messages = []
                    for msg in st.session_state.messages:
                        with st.chat_message(msg["role"]):
                            st.markdown(msg["content"])
                    user_input = st.chat_input("Ask about costs, breakdowns...")
                    if user_input:
                        prompt = user_input
                    if prompt:
                        st.session_state.messages.append({"role": "user", "content": prompt})
                        with st.chat_message("user"):
                            st.markdown(prompt)
                        with st.chat_message("assistant"):
                            with st.spinner("AI is analyzing data..."):
                                try:
                                    llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo", openai_api_key=OPENAI_API_KEY)
                                    agent = create_pandas_dataframe_agent(llm, df, verbose=True, allow_dangerous_code=True, agent_type="openai-functions")
                                    response = agent.run(prompt)
                                    st.markdown(response)
                                    st.session_state.messages.append({"role": "assistant", "content": response})
                                except Exception as e:
                                    st.error(f"AI Error: {str(e)}")

                # 2. COST
                with tabs[1]:
                    st.subheader("Financial Overview")
                    m1, m2, m3 = st.columns(3)
                    act = df['TotSum (actual)'].sum() if 'TotSum (actual)' in df.columns else 0
                    plan = df['TotSum (plan)'].sum() if 'TotSum (plan)' in df.columns else 0
                    m1.metric("Total Actual", f"LKR {act:,.0f}")
                    m2.metric("Total Plan", f"LKR {plan:,.0f}")
                    m3.metric("Variance", f"LKR {act-plan:,.0f}", delta_color="inverse")
                    st.markdown("#### üö® Cost Anomalies (3-Sigma)")
                    if 'TotSum (actual)' in df.columns:
                        mean_cost = df['TotSum (actual)'].mean()
                        std_cost = df['TotSum (actual)'].std()
                        anomalies = df[df['TotSum (actual)'] > (mean_cost + 3 * std_cost)]
                        if not anomalies.empty:
                            st.error(f"Found {len(anomalies)} outliers (Cost > LKR {mean_cost + 3*std_cost:,.0f})")
                            cols_show = [c for c in ['Order', 'Description', 'Equipment description', 'TotSum (actual)'] if c in anomalies.columns]
                            st.dataframe(anomalies[cols_show], use_container_width=True)
                        else:
                            st.success("No significant cost anomalies detected.")
                    else:
                        st.write("No TotSum (actual) column for anomaly detection.")
                    st.divider()
                    c_btn, c_ch = st.columns([1, 2])
                    with c_btn:
                        st.info("View Detailed Tables")
                        if st.button("üîé Open Detailed Costs", type="primary", use_container_width=True):
                            show_cost_popup(df)
                    with c_ch:
                        color_map = {'Mechanical Dpt.': 'red', 'Electrical Dpt.': 'blue'}
                        if 'Main WorkCtr' in df.columns and 'TotSum (actual)' in df.columns:
                            st.plotly_chart(px.pie(df, values='TotSum (actual)', names='Main WorkCtr', title="Cost by Department", color='Main WorkCtr', color_discrete_map=color_map), use_container_width=True)
                    if 'Order Type' in df.columns and 'TotSum (actual)' in df.columns:
                        st.plotly_chart(px.bar(df.groupby('Order Type')['TotSum (actual)'].sum().reset_index(), x='Order Type', y='TotSum (actual)', title="Cost per Order Type"), use_container_width=True)

                # 3. EFFICIENCY
                with tabs[2]:
                    st.subheader("Operational Efficiency")
                    k1, k2, k3 = st.columns(3)
                    wait = df['User Status Text'].str.contains('Awaiting', na=False).sum() if 'User Status Text' in df.columns else 0
                    k1.metric("Approvals Pending", int(wait), delta="Bottleneck", delta_color="inverse")
                    avg_resp = df['Response_Time'].mean() if 'Response_Time' in df.columns else 0
                    k2.metric("Avg Response Time", f"{avg_resp:.1f} Days")
                    k3.metric("Immediate Starts", int(df[df.get('Response_Time', 0) == 0].shape[0]) if 'Response_Time' in df.columns else 0)
                    if 'Response_Time' in df.columns:
                        st.plotly_chart(px.histogram(df, x='Response_Time', nbins=20, title="Response Time Distribution"), use_container_width=True)

                # 4. RELIABILITY
                with tabs[3]:
                    st.subheader("Asset Reliability & MTBF")
                    include_neg_toggle = st.checkbox("Temporarily include filtered negative rows in reliability timelines", value=False)
                    df_for_rel = df.copy()
                    if include_neg_toggle and (st.session_state.get('removed_negatives') is not None) and (not st.session_state['removed_negatives'].empty):
                        df_for_rel = pd.concat([df_for_rel, st.session_state['removed_negatives']], ignore_index=True)
                    if 'Equipment description' in df_for_rel.columns:
                        clean_rel_df = df_for_rel[df_for_rel['Equipment description'] != "Unknown Asset"]
                        st.markdown("#### ‚è±Ô∏è Mean Time Between Failures (MTBF) Analysis")
                        mtbf_data = []
                        for mach, group in clean_rel_df.groupby('Equipment description'):
                            if len(group) > 1:
                                group = group.sort_values('Created_Date')
                                diffs = group['Created_Date'].diff().dt.days.mean()
                                mtbf_data.append({'Machine': mach, 'MTBF_Days': diffs, 'Total_Failures': len(group)})
                        if mtbf_data:
                            mtbf_df = pd.DataFrame(mtbf_data).sort_values('MTBF_Days')
                            col_m1, col_m2 = st.columns(2)
                            with col_m1:
                                st.write("**Lowest MTBF (Frequent Failures)**")
                                st.dataframe(mtbf_df.head(10).style.format({'MTBF_Days': "{:.1f} days"}), use_container_width=True)
                            with col_m2:
                                st.plotly_chart(px.bar(mtbf_df.head(10), x='MTBF_Days', y='Machine', orientation='h', title="Assets requiring frequent attention"), use_container_width=True)
                        else:
                            st.info("Not enough historical data to calculate MTBF.")
                        st.divider()
                        bad = clean_rel_df['Equipment description'].value_counts().reset_index()
                        bad.columns = ['Machine', 'Breakdowns']
                        b1, b2 = st.columns([1, 2])
                        with b1:
                            st.write("**Top 20 Bad Actors (Volume)**")
                            st.dataframe(bad.head(20), use_container_width=True)
                        with b2:
                            st.plotly_chart(px.bar(bad.head(20), x='Breakdowns', y='Machine', orientation='h'), use_container_width=True)
                        st.markdown("#### üìÖ Timeline & Deep Dive")
                        col_tool1, col_tool2 = st.columns(2)
                        with col_tool1:
                            threshold = st.slider("Filter: Show machines with >= X failures", 1, 50, 5)
                        with col_tool2:
                            machines_list = sorted(clean_rel_df['Equipment description'].unique().tolist())
                            selected_machine = st.selectbox("üîç Select Machine to View Details", machines_list)
                            if st.button("View Machine History"):
                                show_machine_details(selected_machine, clean_rel_df)
                        high = bad[bad['Breakdowns'] >= threshold]['Machine']
                        t = clean_rel_df[clean_rel_df['Equipment description'].isin(high)]
                        if not t.empty and 'Start_Date' in t.columns:
                            if 'TotSum (actual)' in t.columns:
                                t = t.copy()
                                t['neg_flag'] = t['TotSum (actual)'].apply(lambda x: 'Negative' if x < 0 else 'Positive')
                                t['plot_size'] = t['TotSum (actual)'].abs() + 1
                                color_map = {'Negative': 'red', 'Positive': '#636efa'}
                                fig_time = px.scatter(t, x='Start_Date', y='Equipment description', size='plot_size', color='neg_flag',
                                                     color_discrete_map=color_map, hover_data=['Description', 'Order', 'Main WorkCtr'], title="Breakdown Timeline")
                            else:
                                fig_time = px.scatter(t, x='Start_Date', y='Equipment description', size='TotSum (actual)' if 'TotSum (actual)' in t.columns else None, color='Main WorkCtr', hover_data=['Description', 'Order'], title="Breakdown Timeline")
                            st.plotly_chart(fig_time, use_container_width=True)
                        if 'Loc_Display' in df_for_rel.columns:
                            st.markdown("#### üî• Location Hotspots")
                            loc_source = 'Location description' if 'Location description' in df_for_rel.columns else 'Loc_Display'
                            loc_list = sorted(df_for_rel[loc_source].astype(str).unique().tolist())
                            c_loc1, c_loc2 = st.columns([1, 2])
                            with c_loc1:
                                selected_loc = st.selectbox("üîç Select Location to View", loc_list)
                                if st.button("View Location Details"):
                                    show_location_details(selected_loc, df_for_rel, include_negatives=include_neg_toggle, removed_df=st.session_state.get('removed_negatives'))
                            locs = df_for_rel[loc_source].value_counts().head(15).reset_index()
                            locs.columns = ['Location', 'count']
                            st.plotly_chart(px.treemap(locs, path=['Location'], values='count'), use_container_width=True)

                # 5. WORKFORCE
                with tabs[4]:
                    st.subheader("Workforce Analysis")
                    w1, w2 = st.columns(2)
                    color_map = {'Mechanical Dpt.': 'red', 'Electrical Dpt.': 'blue'}
                    with w1:
                        if 'Main WorkCtr' in df.columns:
                            st.plotly_chart(px.pie(df, names='Main WorkCtr', title="Dept Share", color='Main WorkCtr', color_discrete_map=color_map), use_container_width=True)
                    with w2:
                        if 'Entered By' in df.columns:
                            st.bar_chart(df['Entered By'].value_counts().head(10))
                    st.markdown("##### üìÖ Daily Workload")
                    if 'Day_Num' in df.columns:
                        day_list = sorted(df['Day_Num'].unique().tolist(), reverse=True)
                        c_day1, c_day2 = st.columns([1, 2])
                        with c_day1:
                            selected_day = st.selectbox("üîç Select Date to Inspect", day_list)
                            if st.button("View Day Details"):
                                show_day_details(selected_day, df)
                        daily = df.groupby('Day_Num').agg(Orders=('Order','count') if 'Order' in df.columns else ('Day_Num','count'), Works_Done=('Description', lambda x: '<br>'.join(x.astype(str).head(5)) if len(x)>0 else '')).reset_index()
                        fig_line = px.line(daily, x='Day_Num', y='Orders', title="Daily Orders Trend", markers=True)
                        st.plotly_chart(fig_line, use_container_width=True)

                # 6. QUALITY
                with tabs[5]:
                    st.subheader("Data Quality")
                    q1, q2 = st.columns(2)
                    q1.metric("Missing Equipment IDs", int(df['Equipment'].isnull().sum()) if 'Equipment' in df.columns else 0, delta_color="inverse")
                    q2.metric("Missing Func. Locs", int(df['Functional Loc.'].isnull().sum()) if 'Functional Loc.' in df.columns else 0)
                    st.write("Top Generic Descriptions:")
                    if 'Description' in df.columns:
                        st.dataframe(df['Description'].value_counts().head(15))
                    else:
                        st.write("No Description column found.")
                    st.markdown("---")
                    st.markdown("#### ‚ö†Ô∏è Filtered Negative Rows (removed during upload)")
                    if st.session_state.get('removed_negatives') is not None and not (st.session_state['removed_negatives'] is None) and not st.session_state['removed_negatives'].empty:
                        if st.button("Show Filtered Negative Rows"):
                            st.session_state['show_filtered_negatives'] = True
                        if st.session_state.get('show_filtered_negatives'):
                            rn = st.session_state['removed_negatives']
                            show_cols = [c for c in ['Order', 'Description', 'Equipment description', 'TotSum (actual)', 'TotSum (plan)', 'Removed_Reason', 'File_Index'] if c in rn.columns]
                            st.dataframe(rn[show_cols], use_container_width=True)
                            if st.button("Undo Filter ‚Äî Restore Negative Rows to Dataset"):
                                merged = pd.concat([st.session_state.get('df_main', pd.DataFrame()), st.session_state['removed_negatives']], ignore_index=True)
                                st.session_state['df_main'] = merged
                                st.session_state['removed_negatives'] = pd.DataFrame()
                                st.session_state['negatives_restored'] = True
                                st.success("Negative rows restored into main dataset. Reload filters if needed.")
                    else:
                        st.info("No filtered negative rows captured for this upload.")

if __name__ == "__main__":
    main()
